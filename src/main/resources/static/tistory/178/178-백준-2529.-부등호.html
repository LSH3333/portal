
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>백준 2529. 부등호</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">백준 2529. 부등호</h2>
                                <div class="box-info">
                                    <p class="category">PS</p>
                                    <p class="date">2021-07-02 22:04:50</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p data-ke-size="size16"><a href="https://www.acmicpc.net/problem/2529" target="_blank" rel="noopener">https://www.acmicpc.net/problem/2529</a></p>
<figure id="og_1625231072052" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="2529번: 부등호" data-og-description="여러분은 제시된 부등호 관계를 만족하는 k+1 자리의 최대, 최소 정수를 첫째 줄과 둘째 줄에 각각 출력해야 한다. 단 아래 예(1)과 같이 첫 자리가 0인 경우도 정수에 포함되어야 한다. 모든 입력" data-og-host="www.acmicpc.net" data-og-source-url="https://www.acmicpc.net/problem/2529" data-og-url="https://www.acmicpc.net/problem/2529" data-og-image="https://scrap.kakaocdn.net/dn/CpE2t/hyKLtoAuEp/ZiHge93JkAYRAmxlaYK3kk/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630"><a href="https://www.acmicpc.net/problem/2529" target="_blank" rel="noopener" data-source-url="https://www.acmicpc.net/problem/2529">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/CpE2t/hyKLtoAuEp/ZiHge93JkAYRAmxlaYK3kk/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630');">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">2529번: 부등호</p>
<p class="og-desc" data-ke-size="size16">여러분은 제시된 부등호 관계를 만족하는 k+1 자리의 최대, 최소 정수를 첫째 줄과 둘째 줄에 각각 출력해야 한다. 단 아래 예(1)과 같이 첫 자리가 0인 경우도 정수에 포함되어야 한다. 모든 입력</p>
<p class="og-host" data-ke-size="size16">www.acmicpc.net</p>
</div>
</a></figure>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이 문제는 생각해보면 결국 모든 순열 조합을 만들어서 부등호를 비교해 조건에 만족하는 순열들 중 가장 큰 순열과 가장 작은 순열을 찾는 것이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">DFS와 백트랙킹을 이용해서 이전과 똑같이 순열을 만들고 부등호 관계가 옳은지를 확인한후 옳다면 ans 벡터에 넣어놓고 마지막에 정렬해서 가장 첫원소와 마지막 원소를 출력한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1625236199272" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

#define MAX 10
using namespace std;

int k;
int nums[MAX];
bool mark[MAX];
char sign[MAX];

// string형태로 저장된 순열들의 집합
vector&lt;string&gt; ans;
// 순열들의 숫자들이 저장됨
vector&lt;char&gt; v;

// 벡터에 들어있는 k개의 숫자들과 부등호의 관계를 비교
// 하나라도 관계가 틀리면 false 리턴
// 모두 옳다면 true 리턴
bool Compare() {
    bool res = true;
    for(int i = 0; i &lt; k; i++) {
        if(sign[i] == '&lt;') {
            // char형을 int형으로 바꿔서 계산
            if(!(v[i]-'0' &lt; v[i+1]-'0')) return false;
        }
        else if(sign[i] == '&gt;') {
            if(!(v[i]-'0' &gt; v[i+1]-'0')) return false;
        }
    }

    return true;
}

void DFS(int depth) {
    if(depth == k+1) {
        // 모든 부등호 관계가 옳다면
        if(Compare()) {
            string temp = "";
            for(int i = 0; i &lt; v.size(); i++) {
                temp += v[i];
            }
            // 만들어진 string을 ans 벡터에 푸쉬
            ans.push_back(temp);
        }
        // 이전 depth로 리턴
        return;
    }


    for(int i = 0; i &lt; 10; i++) {
        if(mark[i]) continue;

        mark[i] = true;
        // +'0'을 함으로서 int형을 char형으로 변환해서 벡터에 저장
        v.push_back(nums[i]+'0');

        DFS(depth+1);

        v.pop_back();
        mark[i] = false;
    }
}

int main() {
    cin &gt;&gt; k;
    // 부등호 sign[]에 저장
    for(int i = 0; i &lt; k; i++)
        cin &gt;&gt; sign[i];

    // 0~9까지의 숫자
    for(int i = 0; i &lt; 10; i++)
        nums[i] = i;

    DFS(0);
    // ans 벡터를 정렬
    sort(ans.begin(), ans.end());

    cout &lt;&lt; ans[ans.size()-1] &lt;&lt; '\n';
    cout &lt;&lt; ans[0] &lt;&lt; '\n';

}

</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">algorithm 라이브러리의 sort 함수가 char나 string 형식의 데이터도 소팅해주는지 처음 알았다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">temp</p>
<div data-ke-type="moreLess" data-text-more="더보기" data-text-less="닫기">
<div class="moreless-content-ignore">
<pre id="code_1625231081891" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;

int k;
char sign[10];
int nums[10];
int mark[10];
vector&lt;int&gt; v;

long long highest = -1;
long long lowest = 0;
bool trigger = false;
int once = 0;

bool Compare(int depth) {
    if(depth &lt;= 1) return true;

    if(sign[depth-2] == '&gt;') {
        if(v[depth-2] &gt; v[depth-1])
            return true;
        else
            return false;
    }
    else {
        if(v[depth-2] &lt; v[depth-1])
            return true;
        else
            return false;
    }

}

void HighestLowest() {
    long long num = 0;
    long long ten = 1;
    for(int i = v.size()-1; i &gt;= 0; i--) {
        if(v[i] == 0) {
            ten *= 10;
            continue;
        }
        num += v[i] * ten;
        ten *= 10;
    }
    if(once == 0) {
        cout &lt;&lt; "num: " &lt;&lt; num &lt;&lt; endl;
        once++;
    }
    if(num &gt; highest)
        highest = num;

    if(!trigger) {
        trigger = true;
        lowest = num;
    }
    if(num &lt; lowest)
        lowest = num;

    /*cout &lt;&lt; "num: " &lt;&lt; num &lt;&lt; endl;
    cout &lt;&lt; "lowest: " &lt;&lt; lowest &lt;&lt; endl;*/
}

void Print() {
    for(int i = 0; i &lt; v.size(); i++) {
        cout &lt;&lt; v[i] &lt;&lt; ' ';
    } cout &lt;&lt; endl;
}

void DFS(int depth) {
    if(depth == k+2) {
        Print();
        HighestLowest();
        return;
    }

    for(int i = 0; i &lt; 10; i++) {
        if(mark[i]) continue;

        mark[i] = true;
        // 벡터에 삽입
        v.push_back(nums[i]);

        // 부등호와 비교해서 false라면 이전 depth로
        if(!Compare(depth)) {
            v.pop_back();
            mark[i] = false;
            return;
        }


        DFS(depth+1);

        mark[i] = false;
        v.pop_back();
    }
}

int main() {
    cin &gt;&gt; k;

    for(int i = 0; i &lt; 10; i++) {
       nums[i] = i;
    }

    for(int i = 0; i &lt; k; i++) {
        cin &gt;&gt; sign[i];
    }


    DFS(1);
    cout &lt;&lt; lowest &lt;&lt; endl;
    cout &lt;&lt; highest &lt;&lt; endl;
}</code></pre>
</div>
</div>
                        </div>
                        <br/>
                        <div class="tags">
                            #C++ #백트래킹 #dfs #순열 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
