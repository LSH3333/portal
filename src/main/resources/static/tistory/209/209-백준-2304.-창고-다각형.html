
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>백준 2304. 창고 다각형</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">백준 2304. 창고 다각형</h2>
                                <div class="box-info">
                                    <p class="category">PS</p>
                                    <p class="date">2021-07-17 17:28:49</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p data-ke-size="size16"><a href="https://www.acmicpc.net/problem/2304" target="_blank" rel="noopener">https://www.acmicpc.net/problem/2304</a></p>
<figure id="og_1626510187944" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="2304번: 창고 다각형" data-og-description="첫 줄에는 기둥의 개수를 나타내는 정수 N이 주어진다. N은 1 이상 1,000 이하이다. 그 다음 N 개의 줄에는 각 줄에 각 기둥의 왼쪽 면의 위치를 나타내는 정수 L과 높이를 나타내는 정수 H가 한 개의" data-og-host="www.acmicpc.net" data-og-source-url="https://www.acmicpc.net/problem/2304" data-og-url="https://www.acmicpc.net/problem/2304" data-og-image="https://scrap.kakaocdn.net/dn/dOMCCO/hyKVaB5ZP0/A5nS5VEqMHU7KqrJuic5G1/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630,https://scrap.kakaocdn.net/dn/595Ij/hyKTRqBhKB/Kn5gKGmY9ffFPjJKq5gEnK/img.png?width=966&amp;height=661&amp;face=0_0_966_661"><a href="https://www.acmicpc.net/problem/2304" target="_blank" rel="noopener" data-source-url="https://www.acmicpc.net/problem/2304">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/dOMCCO/hyKVaB5ZP0/A5nS5VEqMHU7KqrJuic5G1/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630,https://scrap.kakaocdn.net/dn/595Ij/hyKTRqBhKB/Kn5gKGmY9ffFPjJKq5gEnK/img.png?width=966&amp;height=661&amp;face=0_0_966_661');">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">2304번: 창고 다각형</p>
<p class="og-desc" data-ke-size="size16">첫 줄에는 기둥의 개수를 나타내는 정수 N이 주어진다. N은 1 이상 1,000 이하이다. 그 다음 N 개의 줄에는 각 줄에 각 기둥의 왼쪽 면의 위치를 나타내는 정수 L과 높이를 나타내는 정수 H가 한 개의</p>
<p class="og-host" data-ke-size="size16">www.acmicpc.net</p>
</div>
</a></figure>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">처음에는 왼쪽 기둥부터 탐색해서 다음 기둥이 높은지 낮은지 따져서 복잡하게 계산했다.</p>
<p data-ke-size="size16">그렇게 제출했는데 틀렸다고 나와서 다시 생각해보니 이렇게 할 경우 반례가 너무 많이 생겨서 다시 생각했다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">1. 입력받은 기둥들을 위치순으로 정렬한다</p>
<p data-ke-size="size16">2. 가장 높은 기둥을 찾는다</p>
<p data-ke-size="size16">3. 가장 왼쪽부터 높은 기둥까지 탐색하며 더 높은 기둥을 스택에 푸쉬하고 넓이를 계산한다</p>
<p data-ke-size="size16">4. 마찬가지로 가장 오른쪽에서부터 높은 기둥까지 탐색하며 스택에 넣고 넓이를 계산한다</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">오목한 부분이 없어야 하므로 탐색할때 스택에 있는 기둥보다 낮은 기둥은 무시하면된다.</p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1626510505893" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;stack&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;

int n;
int length = 0;
vector&lt;pair&lt;int,int&gt;&gt; columns;

// 가장 높은 기둥의 columns 벡터에서의 인덱스 찾음
int FindHighestColumnIndex()
{
    int highestIndex = 0;
    int highest = 0;
    for(int i = 0; i &lt; columns.size(); i++)
    {
        if(columns[i].second &gt; highest)
        {
            highest = columns[i].second;
            highestIndex = i;
        }
    }

    return highestIndex;
}

int main()
{
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++)
    {
        int a,b;
        cin &gt;&gt; a &gt;&gt; b;
        columns.push_back({a,b});
    }

    // 정렬
    sort(columns.begin(), columns.end());

    // 가장 높은 기둥의 인덱스
    int HighestColumnIndex = FindHighestColumnIndex();

    // 가장 높은 기둥이 가장 왼쪽이 아닐 경우에만
    if(HighestColumnIndex != 0)
    {
        // 왼쪽부터 가장 높은 기둥까지
        // 스택의 top에는 항상 지금까지 중 가장 높은 기둥이 위치한다
        stack&lt;pair&lt;int,int&gt;&gt; st;
        // 가장 왼쪽 기둥
        st.push(columns[0]);
        for(int i = 1; i &lt; HighestColumnIndex; i++)
        {
            // 스택 top에 있는 기둥보다 높다면
            if(columns[i].second &gt; st.top().second)
            {
                int width = columns[i].first - st.top().first;
                int height = st.top().second;
                length += width * height;

                st.push(columns[i]);

            }
        }
        length += (columns[HighestColumnIndex].first - st.top().first) * st.top().second;
    }

    // 가장 높은 기둥이 가장 오른쪽이 아닐 경우에만
    if(HighestColumnIndex != columns.size()-1)
    {
        // 오른쪽부터 가장 높은 기둥까지
        stack&lt;pair&lt;int,int&gt;&gt; st2;

        // 가장 오른쪽 기둥
        st2.push(columns[columns.size()-1]);

        // 오른쪽 부터 가장 높은 기둥ㄱ까지 탐색
        for(int i = columns.size()-2; i &gt; HighestColumnIndex; i--)
        {
            if(columns[i].second &gt; st2.top().second)
            {
                int width = st2.top().first - columns[i].first;
                int height = st2.top().second;
                length += width * height;
                st2.push(columns[i]);
            }
        }
        length += (st2.top().first - columns[HighestColumnIndex].first) * st2.top().second;
    }
    // 마지막으로 가장 높은 기둥의 넓이 더함
    length += columns[HighestColumnIndex].second;
    cout &lt;&lt; length;
}</code></pre>
                        </div>
                        <br/>
                        <div class="tags">
                            #C++ #Stack #brute_force 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
