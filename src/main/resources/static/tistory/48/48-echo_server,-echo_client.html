
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>echo_server, echo_client</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">echo_server, echo_client</h2>
                                <div class="box-info">
                                    <p class="category">학교/OSNW</p>
                                    <p class="date">2020-10-16 21:23:35</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p>echo_client1 ~ 3에서 각각 문자열을 echo_server로 보내면 concat해서 다시 각각의 클라이언트로 보내는 프로그램.</p>
<p>&nbsp;</p>
<p><b>echo_server.c</b></p>
<pre id="code_1602850317578" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;sys/socket.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

#define MAXBUF 1024

int main(int argc, char **argv)
{
        int server_sockfd, client_sockfd;
        int client_len, n;
        char buf[MAXBUF];
        struct sockaddr_in clientaddr, serveraddr;
        client_len = sizeof(clientaddr);

        char concat[MAXBUF] = "";
        int client_sockfd_arr[10];

        // socket
        if((server_sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1)
        {
                perror("socket error : ");
                exit(0);
        }
        // 구조체 선언
        memset(&amp;serveraddr, 0x00, sizeof(serveraddr));
        serveraddr.sin_family = AF_INET;
        serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
        serveraddr.sin_port = htons(atoi(argv[1]));

        // bind
        bind(server_sockfd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr));
        // listen
        listen(server_sockfd, 5);

        for(int i = 0; i &lt; 3; i++)
        {
                // accept
                client_sockfd_arr[i] = accept(server_sockfd, (struct sockaddr *)$

                printf("New Client Connect: %s\n", inet_ntoa(clientaddr.sin_addr$
                memset(buf, 0x00, MAXBUF);

                // read
                read(client_sockfd_arr[i], buf, MAXBUF);

                printf("From client[%d]: %s", i, buf);

                // concat
                int len = strlen(buf);
                buf[len-1] = ' ';
                strcat(concat, buf);


        }

        for(int i = 0; i &lt; 3; i++)
        {
                write(client_sockfd_arr[i], concat, strlen(concat));
                close(client_sockfd_arr[i]);
        }

        close(server_sockfd);

        return 0;
}
</code></pre>
<p>&nbsp;</p>
<p><b>echo_client.c</b></p>
<pre id="code_1602850392755" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;sys/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;

#define MAXLINE 1024

int main(int argc, char **argv)
{
        struct sockaddr_in serveraddr;
        int server_sockfd;
        int client_len;
        char buf[MAXLINE];

        // socket
        if((server_sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        {
                perror("error : ");
                return 1;
        }

        // 구조체 선언
        server_sockfd = socket(AF_INET, SOCK_STREAM, 0);
        serveraddr.sin_family = AF_INET;
        serveraddr.sin_addr.s_addr = inet_addr("127.0.0.1");
        serveraddr.sin_port = htons(3600);

        client_len = sizeof(serveraddr);

        // connect
        if(connect(server_sockfd, (struct sockaddr *)&amp;serveraddr, client_len) ==$
        {
                perror("connect error :");
                return 1;
        }

        memset(buf, 0x00, MAXLINE);

        read(0, buf, MAXLINE); // 키보드 입력 대기
        // write
        if(write(server_sockfd, buf, MAXLINE) &lt;= 0)
        {
                perror("write error : ");
                return 1;
        }

        memset(buf, 0x00, MAXLINE);

        // read, EOF 받을때까지 계속~read 중..
        while(read(server_sockfd, buf, MAXLINE) != 0)


        printf("read : %s\n", buf);

        close(server_sockfd);

        return 0;

}
</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>수업시간에 서버와 클라이언트의 1:1통신만 배워서 처음에 어떻게 하나의 서버에 여러개의 클라이언트를 연결할까</p>
<p>고민하다가 배열을 만들어서 accept의 반환값을(클라이언트의 주소) 그곳에 저장하는 방식으로 했다.</p>
<p>&nbsp;</p>
<p>그리고 총 3개의 클라이언트로부터 연결될것이므로 for문으로 반복.</p>
<p>&nbsp;</p>
<p>계속 문제가 됐던 부분은 알고보니 클라이언트 쪽 부분이었다.</p>
<p>만약 서버에서 <b>close(client_sockfd)</b>이런식으로 닫게되면 클라이언트의 <b>read</b>에 EOF가 반환되고</p>
<p style="text-align: center;">while(read(server_sockfd,&nbsp;buf,&nbsp;MAXLINE)&nbsp;!=&nbsp;0)</p>
<p>이부분의 while문을 탈출하게된다.</p>
<p>&nbsp;</p>
<p>그러니까 서버에서 클라이언트1의 문자열받고, 클라이언트2 문자열받고, 클라이언트3 문자열받고...</p>
<p>하는 동안 클라이언트들이 종료가 안되게 해야됐는데</p>
<p style="text-align: center;"><span style="color: #333333;">while(read(server_sockfd,&nbsp;buf,&nbsp;MAXLINE)&nbsp;!=&nbsp;0)</span></p>
<p style="text-align: left;"><span style="color: #333333;">이런식으로 하게되면, 클라이언트에서 서버로 문자열 보낸후 계속 read를 반복하다가(이때는 0이 아닌값이므로),</span></p>
<p style="text-align: left;"><span style="color: #333333;">서버쪽에서 close(client_sockfd)를 해서 닫히면, EOF를 클라이언트의 read로 전송하므로 while문 안의 값이 0이 되므로&nbsp;</span></p>
<p style="text-align: left;"><span style="color: #333333;">while문을 종료하게 된다.</span></p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;"><span style="color: #333333;">여기서 햇갈렸던게 원래 EOF는 -1로 표현되는데 교재의 read함수에 관한걸 보면</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<p style="text-align: left;"><span style="color: #333333;">#include &lt;unistd.h&gt;</span></p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;"><span style="color: #333333;">ssize_t read(int fd, void *buf, size_t nbytes);</span></p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;"><span style="color: #333333;">성공시 수신한 바이트 수 <b>(단 파일의 끝을 만나면 0),</b> 실패 시 -1 반환.</span></p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<p style="text-align: left;">read함수는 파일의 끝(EOF)를 만나면 0을 반환한다고 되어있다.</p>
<p style="text-align: left;">&nbsp;</p>
                        </div>
                        <br/>
                        <div class="tags">
                            #osnw #echo_server 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
