
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>The rule of 3 / 0</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">The rule of 3 / 0</h2>
                                <div class="box-info">
                                    <p class="category">노트</p>
                                    <p class="date">2022-03-24 16:24:31</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <h2 data-ke-size="size26"><b>rule of 3</b></h2>
<p data-ke-size="size16">만약 클래스에 사용자가 정의한&nbsp;<b>복사 생성자, 소멸자, 복사 연산자(연산자 오버로딩)</b> 중 하나라도 선언되어 있다면 <b>세가지 모두 선언되어야 한다</b>는 법칙이다.</p>
<p data-ke-size="size16">3가지 모두가 필요한 이유는 리소스를 일관되게 관리하기 위함이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">위 3가지를 직접 정의하지 않으면 <b>디폴트</b> 복사 생성자, 소멸자, 복사 연산자가 필요시 자동 호출되는데 그때 <b>얕은 복사</b>가 일어난다.</p>
<p data-ke-size="size16">예를들어 하나의 객체가 다른 객체로 부터 디폴트 복사 생성자나 복사 연산자에 의해 복사됐을때를 생각해 보면.</p>
<p data-ke-size="size16">하나의 <b>객체를 삭제</b>하게 되면 객체가 갖고 있는 맴버의 주소값이 제거되고 또 다른 객체가 제거 될때 이미 제거된 주소값을 또 다시 제거하게 된다. (얕은 복사에 의해 같은 주소값을 가르키고 있으므로)&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">다른 경우는 <b>객체가 복사될 때</b> 문제가 생긴다.</p>
<p data-ke-size="size16">다음과 같이 객체를 <b>디폴트 복사 생성자</b>에 의해 복사하게 되면&nbsp;</p>
<pre id="code_1648105963373" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>Class cls1 = new Class("className");
Class cls2 = cls1; // 디폴트 복사 생성자 호출</code></pre>
<p data-ke-size="size16">디폴트 복사 생성자는 얕은 복사를 하기 때문에 cls2는 cls1가 가르키고 있는 "className"과 같은 주소를 가르키게 된다.</p>
<p data-ke-size="size16">그런데 만약 cls2가 이미 어떤 주소값을 가르키고 있던 상황이라면 기존의 가르키고 있던 주소값은 디폴트 복사 생성자에 의해 바뀌어 버리므로 기존의 주소값은 잃어버려 메모리 누수로 이어진다.</p>
<p data-ke-size="size16">(디폴트 대입 연산자: <a href="https://tose33.tistory.com/595" target="_blank" rel="noopener">https://tose33.tistory.com/595</a>)</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><b>rule of 0</b></h2>
<p data-ke-size="size16">rule of 0는 rule of 3와 같은 구식 스타일의 메모리 할당을 피하는 것이다.</p>
<p data-ke-size="size16">즉 <b>배열 대신 vector와 같은 클래스를, char 배열 대신 string 클래스를 사용하면 rule of 3에서 발생하는 문제들을 해당 클래스가 내부적으로 해결</b>해 주기 때문에 다른 클래스들은 사용자 정의 복사 생성자, 복사 연산자 등을 갖지 않도록 하는 것.</p>
                        </div>
                        <br/>
                        <div class="tags">
                            #C++ 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
