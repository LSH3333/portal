
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>DFS</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">DFS</h2>
                                <div class="box-info">
                                    <p class="category">알고리즘</p>
                                    <p class="date">2021-03-16 20:49:00</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p>&nbsp;</p>
<p><b>Stack 사용</b></p>
<pre id="code_1615894993789" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;
using namespace std;

vector&lt;int&gt; edge[10];
bool mark[10];

void dfs(int n) {
    stack&lt;int&gt; s;

    s.push(n);
    mark[n] = true;
    cout &lt;&lt; n &lt;&lt; ' ';

    while(!s.empty()) {
        int f = s.top();
        bool none = true;
        for(int x : edge[f]) { // 정점에 연결된 모든 간선 탐색
            if(!mark[x]) {
                s.push(x);
                mark[x] = true;
                cout &lt;&lt; x &lt;&lt; ' ';
                none = false;
                break;
            }
        }
        // none이 true면 그래프에서 더이상 진행할곳이 없음
        // 현재 정점에서 이어진 곳이 모두 이미 방분됨.
        if(none) s.pop();

    }

}

int main() {
    int v, e; // vertex, edge
    cin &gt;&gt; v &gt;&gt; e;

    for(int i = 0; i &lt; e; i++) {
        int f, t;
        cin &gt;&gt; f &gt;&gt; t;
        edge[f].push_back(t);
        edge[t].push_back(f);
    }

    dfs(1);
}</code></pre>
<p>&nbsp;</p>
<p><b>input:</b></p>
<p>6 8&nbsp; // vertex, edge</p>
<p>1 2</p>
<p>1 5</p>
<p>2 3</p>
<p>2 4</p>
<p>2 5</p>
<p>3 4</p>
<p>4 5</p>
<p>4 6</p>
<p>&nbsp;</p>
<p><figure class="imageblock alignLeft" data-filename="스크린샷 2021-03-16 오후 8.45.16.png" data-origin-width="296" data-origin-height="434" width="200" height="NaN" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img.png" data-filename="스크린샷 2021-03-16 오후 8.45.16.png" data-origin-width="296" data-origin-height="434" width="200" height="NaN" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption>vector&lt;int&gt; edge[10]에 저장된 간선들</figcaption>
</figure></p>
<p>&nbsp;</p>
<p><figure class="imageblock alignLeft" data-filename="SmartSelect_20210316-204732_Samsung Notes.jpg" data-origin-width="899" data-origin-height="452" width="420" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img.jpg" data-filename="SmartSelect_20210316-204732_Samsung Notes.jpg" data-origin-width="899" data-origin-height="452" width="420" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<p><b>재귀 사용</b></p>
<p>&nbsp;</p>
<pre id="code_1615964990452" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

vector&lt;int&gt; edge[10];
bool mark[10];

void dfs(int n, int from) {
    if(mark[n]) {
        cout &lt;&lt; "I'm from: " &lt;&lt; from &lt;&lt; ", n is: " &lt;&lt; n &lt;&lt; ". return" &lt;&lt; '\n';
        return;
    }

    mark[n] = true;
    cout &lt;&lt; "im from: "&lt;&lt; from &lt;&lt; ", n is: " &lt;&lt; n &lt;&lt; '\n';
    for(int x : edge[n]) {  dfs(x,n); }
}

int main() {
    int v, e;
    cin &gt;&gt; v &gt;&gt; e;

    for(int i = 0; i &lt; e; i++) {
        int f, t;
        cin &gt;&gt; f &gt;&gt; t;
        edge[f].push_back(t);
        edge[t].push_back(f);
    }
    dfs(1,1);
}</code></pre>
<p><figure class="imageblock alignLeft" width="200" height="NaN" data-filename="스크린샷 2021-03-16 오후 8.45.16.png" data-origin-width="296" data-origin-height="434" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png" width="200" height="NaN" data-filename="스크린샷 2021-03-16 오후 8.45.16.png" data-origin-width="296" data-origin-height="434" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption>vector&lt;int&gt; edge[10]에 저장된 간선들</figcaption>
</figure></p>
<p><b>결과:</b></p>
<p><figure class="imageblock alignLeft" data-filename="스크린샷 2021-03-17 오후 4.10.07.png" data-origin-width="520" data-origin-height="1104" width="263" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img_2.png" data-filename="스크린샷 2021-03-17 오후 4.10.07.png" data-origin-width="520" data-origin-height="1104" width="263" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p>지금까지 별 생각 없이 재귀를 사용하고 있었는데, 재귀가 dfs랑 상당히 비슷하게 작동한다는 것을 배울수 있었다.</p>
<p>재귀함수가 실행될때, 예를들어 2번 정점을 검토할때, 1은 이미 방문했으므로 리턴되고, 3은 아직 방문하지 않았으므로 dfs(3)이 실행되는데,</p>
<p>이때 edge[2]에 아직 4와 5가 남아있다.&nbsp;</p>
<p>이때 dfs(3)이 먼저 실행되고(그 안에서 재귀함수들이 또 쭉 호출된다), 그 이후 돌아와서 dfs(4), dfs(5)가 호출된다.</p>
<p>즉 재귀가 dfs 그 자체처럼 하나의 요소를 쭉 파고들고 다시 돌아오는 방식으로 작동된다.</p>
                        </div>
                        <br/>
                        <div class="tags">
                            #C++ #dfs 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
