
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>백준 9663. N-Queen</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">백준 9663. N-Queen</h2>
                                <div class="box-info">
                                    <p class="category">PS</p>
                                    <p class="date">2021-08-04 14:25:49</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p data-ke-size="size16"><a href="https://www.acmicpc.net/problem/9663" target="_blank" rel="noopener">https://www.acmicpc.net/problem/9663</a></p>
<figure id="og_1628054239446" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="9663번: N-Queen" data-og-description="N-Queen 문제는&nbsp;크기가 N &times; N인 체스판 위에 퀸 N개를&nbsp;서로 공격할 수 없게 놓는&nbsp;문제이다. N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오." data-og-host="www.acmicpc.net" data-og-source-url="https://www.acmicpc.net/problem/9663" data-og-url="https://www.acmicpc.net/problem/9663" data-og-image="https://scrap.kakaocdn.net/dn/ud4T6/hyK6pU6tgT/UaN9n18VWnG48cAjYL72dK/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630"><a href="https://www.acmicpc.net/problem/9663" target="_blank" rel="noopener" data-source-url="https://www.acmicpc.net/problem/9663">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/ud4T6/hyK6pU6tgT/UaN9n18VWnG48cAjYL72dK/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630');">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">9663번: N-Queen</p>
<p class="og-desc" data-ke-size="size16">N-Queen 문제는&nbsp;크기가 N &times; N인 체스판 위에 퀸 N개를&nbsp;서로 공격할 수 없게 놓는&nbsp;문제이다. N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.</p>
<p class="og-host" data-ke-size="size16">www.acmicpc.net</p>
</div>
</a></figure>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">백트래킹의 가장 유명한 문제중 하나인&nbsp; N-Queen 이다.</p>
<p data-ke-size="size16">사실 이문제에서 막혀서 최근 한달정도 브루트포스, 재귀, dfs 문제만 풀었다.</p>
<p data-ke-size="size16">한달전쯤 이문제를 풀다가 모르겠어서 다른 분들이 푼것을 봤는데 백트래킹, 특히 재귀를 이용하는 부분이 전혀 이해가 안갔다.</p>
<p data-ke-size="size16">그 후 한달정도 재귀,dfs 관련 문제를 많이 풀었고 오늘 다시 풀어봤다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">한달동안 집중적으로 공부한 보람이 있었는지 쉽게 풀렸다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">재귀를 이용한 dfs 방식으로 첫행에 퀸을 놓는데,&nbsp;</p>
<p data-ke-size="size16">퀸은 상하좌우에 대각선까지 이동한다. 그런데 체스판의 아래방향은 아직 퀸을 놓지않았기 때문에(0번째 행부터 순서대로 놓는다)</p>
<p data-ke-size="size16">북서, 북, 북동 방향만 탐색하면된다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">NQueen(depth+1) 을 호출해 다음 depth로 넘어간다. 여기서 depth는 체스판의 행번호나 마찬가지다.</p>
<p data-ke-size="size16">마찬가지로 북서,북,북동 방향을 탐색해서 퀸이 없으면 퀸을 놓는다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이렇게 퀸을 놓다가 depth가 n즉 마지막 행까지 퀸을 다 놓았다면 ans값을 1늘리고 리턴하므로</p>
<p data-ke-size="size16">마지막에 놓았던 퀸을 다음 자리에 놓아본다. 이를 반복한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">만약 depth가 n을 도달하지 못하고, 즉 마지막 행까지 퀸을 놓지 못했는데 더이상 퀸을 놓을수 있는곳이 없다면</p>
<p data-ke-size="size16">for문이 끝에 도달하므로 이전 depth (행)으로 리턴되고 다음 칸에 퀸을 놓아볼것이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1628054379993" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
using namespace std;

int n;
int ans = 0;
int map[15][15];

int dr[3] = {-1, -1, -1};
int dc[3] = {-1, 0, 1};

// 북서, 북, 북동 방향 경로에 퀸있는지 탐색
bool Check(int r, int c)
{
    for(int i = 0; i &lt; 3; i++)
    {
        int nr = r + dr[i];
        int nc = c + dc[i];
        // 체스판 범위 벗어나지 않을때까지 퀸이 있나 체크
        while(nr &gt;= 0 &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; n)
        {
            // 퀸이 있으므로 해당하는 자리에는 퀸을 놓을수 없음
            if(map[nr][nc] == 1) return false;
            nr += dr[i];
            nc += dc[i];
        }
    }
    return true;
}


void NQueen(int depth)
{
    if(depth == n)
    {

        ans++;
        return;
    }

    for(int i = 0; i &lt; n; i++)
    {
        // 퀸을 놓을수 있는곳이라면
        if(Check(depth, i))
        {
            map[depth][i] = 1;

            NQueen(depth+1);

            map[depth][i]= 0;
        }
    }

}

int main()
{
    cin &gt;&gt; n;

    NQueen(0);

    cout &lt;&lt; ans;
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<p data-ke-size="size16">다른 분들 코드를 본 후에 부족했던 부분을 보충해본다.</p>
<p data-ke-size="size16">크게 다른점은 두가지였다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>1. 체스판을 2차원 배열이 아닌 1차원 배열로 만든다.</b></p>
<p data-ke-size="size16">1차원 배열의 인덱스를 행, 값을 열로 만들면 2차원이 아닌 1차원 배열로도 체스판의 어느 지점에 퀸을 놓았는지 표현할수 있다.</p>
<p data-ke-size="size16">예를들어 배열이</p>
<p data-ke-size="size16">col[0] = 0 이라면 (0,0)에 퀸을 놓았다는 뜻이고</p>
<p data-ke-size="size16">col[2] = 3 이라면 (2,3)에 퀸을 놓았다는 뜻이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>2. 퀸을 놓을수 있는지 판단하는 방법.</b></p>
<p data-ke-size="size16">나는 퀸을 놓을곳으로부터 북서, 북, 북동으로 쭉 이동하면서 경로상에 퀸이 하나도 없으면 그 자리에 퀸을 놓을수 있다고 판단했다.</p>
<p data-ke-size="size16">더 좋은 방법이 있었다,&nbsp;</p>
<p data-ke-size="size16">먼저 체스판을 나타내는 배열을 1차원 배열로 선언했기 때문에 배열에 저장되어 있는 값이 같다면 같은 열에 있다는 뜻이다.</p>
<p data-ke-size="size16">예를들어 col[2] = 2이면 (2,2)에 퀸이 있고</p>
<p data-ke-size="size16">col[3] = 2면 (3,2)에 퀸이있기 때문에<b> 같은 열에 퀸이 존재</b>하므로 퀸을 놓을수 없다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>대각선</b>의 경우는 (r1, c1), (r2, c2) 두 지점을 비교할때 r1-r2 == abs(c1-c2) 라면 대각선상에 같이 존재한다.</p>
<p data-ke-size="size16">즉 두 지점의 인덱스의 차와 값의 차가 같다면 대각선상에 같이 존재하므로 퀸을 놓을수 없다.</p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1628057074590" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
using namespace std;

int n;
int ans = 0;
// 인덱스가 행, 값이 열
// col[0] = 0 은 (0,0)에 퀸 놓음
// col[1] = 2 는 (1,2)에 퀸 놓음
int col[16] = {-1,};

// (r,c)에 퀸을 놓을수 있는지 판단
bool Check(int r, int c)
{
    // r행,c열에 퀸을 놓아봄
    col[r] = c;
    for(int i = 0; i &lt; r; i++)
    {
        // 같은 열에 있다면 충돌함
        if(col[i] == col[r])
            return false;
        // 현재 row의 퀸과 i레벨의 퀸이 대각선에 있다면 충돌함
        else if(r-i == abs(col[r]-col[i]))
            return false;
    }
    return true;
}

void NQueen(int row)
{
    if(row == n)
    {
        ans++;
        return;
    }

    for(int i = 0; i &lt; n; i++)
    {
        // (row,i)에 놓을수 있다면 놓는다
        if(Check(row, i))
        {
            col[row] = i;
            NQueen(row+1);
            col[row] = -1;
        }
    }
}

int main()
{
    cin &gt;&gt; n;

    NQueen(0);

    cout &lt;&lt; ans;
}</code></pre>
                        </div>
                        <br/>
                        <div class="tags">
                            #C++ #Brute Force #backtracking 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
