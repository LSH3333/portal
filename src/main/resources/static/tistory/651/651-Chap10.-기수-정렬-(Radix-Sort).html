
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>Chap10. 기수 정렬 (Radix Sort)</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">Chap10. 기수 정렬 (Radix Sort)</h2>
                                <div class="box-info">
                                    <p class="category">윤성우의 열혈 자료구조</p>
                                    <p class="date">2022-04-15 22:07:29</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p data-ke-size="size16"><b>기수(Radix)</b> 란 데이터를 구성하는 기본 요소를 의미한다.</p>
<p data-ke-size="size16">2진수는 0과1, 10진수는 0~9, 알파벳은 'a' ~ 'z' ...&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">정렬 알고리즘의 이론상 성능의 한계는 O(NlogN)이다.&nbsp;</p>
<p data-ke-size="size16">그런데 <b>기수 정렬의 시간복잡도는 O(N)으로, O(NlogN) 보다 빠를수 있는 유일한 알고리즘이다.&nbsp;</b></p>
<p data-ke-size="size16">이렇게 빠를수 있는 이유는 비교 연산이 없고 <b>메모리</b>를 이용해 정렬을 하기 때문이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><b>LSD 기수 정렬&nbsp;</b></h2>
<p data-ke-size="size16">일반적으로 기수 정렬이라 함은 <b>LSD (Least Significant Digit)</b> 기수 정렬을 의미한다.</p>
<p data-ke-size="size16">LSD 기수 정렬은 말그대로 least significant digit 즉 <b>첫 자리부터 시작</b> 해서 정렬을 진행한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><u><b>3자리 정수의 첫번째 자리&nbsp;</b></u></p>
<p data-ke-size="size16">숫자들을 첫번째 자리를 비교해 <b>순서대로</b> 해당하는 기수의 큐에 넣는다.</p>
<p data-ke-size="size16">예를들어 <b>5진수 134, 224, 232, 122</b> 를 정렬한다고 하면 첫 자리를 비교해 해당하는 자리에 넣는다.</p>
<table style="border-collapse: collapse; width: 24.2601%; height: 209px;" border="1" data-ke-align="alignLeft">
<tbody>
<tr>
<td style="width: 50%;"><b>0자리</b></td>
<td style="width: 50%;">&nbsp;</td>
</tr>
<tr>
<td style="width: 50%;"><b>1자리</b></td>
<td style="width: 50%;">&nbsp;</td>
</tr>
<tr>
<td style="width: 50%;"><b>2자리</b></td>
<td style="width: 50%;">12<b>2</b>, 23<b>2</b></td>
</tr>
<tr>
<td style="width: 50%;"><b>3자리</b></td>
<td style="width: 50%;">&nbsp;</td>
</tr>
<tr>
<td style="width: 50%;"><b>4자리</b></td>
<td style="width: 50%;">22<b>4</b>, 13<b>4</b></td>
</tr>
</tbody>
</table>
<p data-ke-size="size16">134는 첫자리가 4이므로 4자리에 넣고, 224도 첫자리가 4이므로 4에 이어서 넣는다.</p>
<p data-ke-size="size16">232는 첫자리가 2이므로 2자리에 넣고, 122도 첫자리가 2이므로 2에 이어서 넣는다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">그후 0자리 부터 순서대로 큐에서 pop해서 정렬한다.</p>
<p data-ke-size="size16">(큐는 First in First out)</p>
<p data-ke-size="size16"><b>232, 122, 134, 224</b></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><u><b>3자리 정수의 두번째 자리&nbsp;</b></u></p>
<p data-ke-size="size16">이제 첫번쨰 자리 기준으로 정렬된 숫자들을 다시 두번째 자리를 기준으로 비교해 해당하는 기수에 <b>순서대로 </b>넣는다.</p>
<table style="border-collapse: collapse; width: 24.2601%; height: 120px;" border="1" data-ke-align="alignLeft">
<tbody>
<tr style="height: 24px;">
<td style="width: 50%; height: 24px;"><b>0자리</b></td>
<td style="width: 50%; height: 24px;">&nbsp;</td>
</tr>
<tr style="height: 24px;">
<td style="width: 50%; height: 24px;"><b>1자리</b></td>
<td style="width: 50%; height: 24px;">&nbsp;</td>
</tr>
<tr style="height: 24px;">
<td style="width: 50%; height: 24px;"><b>2자리</b></td>
<td style="width: 50%; height: 24px;">2<b>2</b>4, 1<b>2</b>2</td>
</tr>
<tr style="height: 24px;">
<td style="width: 50%; height: 24px;"><b>3자리</b></td>
<td style="width: 50%; height: 24px;">1<b>3</b>4, 2<b>3</b>2</td>
</tr>
<tr style="height: 24px;">
<td style="width: 50%; height: 24px;"><b>4자리</b></td>
<td style="width: 50%; height: 24px;">&nbsp;</td>
</tr>
</tbody>
</table>
<p data-ke-size="size16">마찬가지로 0자리 부터 내려오면서 순서대로 pop한다.</p>
<p data-ke-size="size16"><b>122, 224, 232, 134</b></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">자 여기서 2자리를 보면 122가 224보다 큐에 먼저 들어갔다. 즉 빼내어서 정렬할때 122가 224보다 앞선다는 뜻이다.</p>
<p data-ke-size="size16">아직 3번째 자리 기준으로는 정렬을 안했으므로 122는 22, 224는 24라고 볼수 있다.&nbsp;</p>
<p data-ke-size="size16">이렇게 될 수 있었던 이유는 첫 번째 자리 기준 정렬을 하고 그 순서대로 큐에 넣었기 때문이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><u><b>3자리 정수의 세번째 자리&nbsp;</b></u></p>
<p data-ke-size="size16">마지막으로 세번째 자리 기준도 진행하면&nbsp;</p>
<table style="border-collapse: collapse; width: 24.2601%; height: 120px;" border="1" data-ke-align="alignLeft">
<tbody>
<tr>
<td><b>0자리</b></td>
<td>&nbsp;</td>
</tr>
<tr>
<td><b>1자리</b></td>
<td><b>1</b>34, <b>1</b>22</td>
</tr>
<tr>
<td><b>2자리</b></td>
<td><b>2</b>32, <b>2</b>24</td>
</tr>
<tr>
<td><b>3자리</b></td>
<td>&nbsp;</td>
</tr>
<tr>
<td><b>4자리</b></td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p data-ke-size="size16">큐에서 pop 하면&nbsp;</p>
<p data-ke-size="size16"><b>122, 134, 224, 232&nbsp;</b></p>
<p data-ke-size="size16">정렬이 완료되었다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>LSD 기수 정렬의 단점</b>은 가장 작은 자릿수부터 비교하기 때문에 모든 자릿수를 모두 비교하고 나서야 정렬이 완료된다.</p>
<p data-ke-size="size16">가장 영향력이 큰 자릿수를 마지막에 비교하기 때문에 마지막까지 정렬 결과를 알 수 없다.</p>
<p data-ke-size="size16">&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<h2 data-ke-size="size26"><b>MSD 기수 정렬</b></h2>
<p data-ke-size="size16">MSD 기수 정렬은 Most Significant Digit 기수 정렬, 즉 LSD와 반대로 큰 자릿수부터 비교하는 것이다.</p>
<p data-ke-size="size16">MSD 기수 정렬은 LSD 기수 정렬과 반대로만 하면 된다고 생각할수 있지만 그렇지 않다.</p>
<p data-ke-size="size16">224, 232를 MSD 기수 정렬을 한다고 생각해보면, 세번째 자리와 두번째 자리 까지 비교를 한 이후에는 224, 232 순서대로 정렬되었을 것이다. (3이 2보다 크기 때문에)&nbsp;</p>
<p data-ke-size="size16">그런데 여기서 <b>마지막으로 첫번째 자리를 기준으로 정렬을 하면 4가 2 보다 크기 때문에 정렬결과는 232, 224 가 된다.</b></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">즉 MSD 기수 정렬은 큰 자릿수부터 정렬을 해나가면서 중간중간 데이터를 점검해야 한다.</p>
<p data-ke-size="size16">위와 같은 경우 <b>두번째 자리까지 완료했을때 232가 224보다 확실히 크다는 것이 결정되므로 여기서 더 이상의 과정이 진행되지 않도록 해야 한다.&nbsp;</b></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><u><b>단점</b></u></p>
<p data-ke-size="size16">즉! MSD 기수 정렬은 LSD 기수 정렬과 다르게 큰 자릿수부터 비교하므로 금방 대략적인 대소 관계가 판단이 되서 정렬 과정이 단축될수 있지만, 중간 중간 데이터를 점검해 어떤 데이터들은 더 이상 진행이 되지 않도록 해야하며, 이 과정에서 성능의 이점도 반감될수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<h2 data-ke-size="size26"><b>기수 정렬, LSD 기준 구현</b></h2>
<p data-ke-size="size16">위에서 말한 MSD 기수 정렬의 단점에 의해 대부분의<b> 기수 정렬은 LSD 기준으로 구현</b>한다.</p>
<p data-ke-size="size16">결과적으로 LSD, MSD 의 시간복잡도는 동일하고,&nbsp;</p>
<p data-ke-size="size16">MSD 기준 정렬은 모든 데이터에 일괄적인 과정을 거치게 할 수 없어 추가적인 연산과 별도의 메모리가 필요할수 있기 때문이다.&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">bucket은 First in First out이어야 하므로 큐라고 위에서 말했었다.&nbsp;</p>
<p data-ke-size="size16">구현해 놓은 ListBaseQueue 를 사용.&nbsp;</p>
<pre class="reasonml"><code>#include &lt;stdio.h&gt;
#include "ListBaseQueue.h"

#define BUCKET_NUM 10

// maxLen은 가장 긴 데이터의 길이
void RadixSort(int arr[], int num, int maxLen)
{
    Queue buckets[BUCKET_NUM];
    int pos, bi, di, divfac=1, radix;
    // 큐 초기화
    for(int i = 0; i &lt; BUCKET_NUM; i++)
        QueueInit(&amp;buckets[i]);

    // 가장 긴 데이터의 길이만큼 반복
    for(pos = 0; pos &lt; maxLen; pos++)
    {
        // 정렬 대상 수 만큼 반복
        for(di=0; di &lt; num; di++)
        {
            // N번쨰 자리의 숫자 추출
            radix = (arr[di] / divfac) % 10;

            // 추출한 숫자를 근거로 버킷에 데이터 저장
            Enqueue(&amp;buckets[radix], arr[di]);
        }

        // 버킷 수만큼 반복
        for(bi = 0, di = 0; bi &lt; BUCKET_NUM; bi++)
        {
            // 버킷에 저장된 순서대로 꺼내 다시 arr에 저장
            while(!QIsEmpty(&amp;buckets[bi]))
                arr[di++] = Dequeue(&amp;buckets[bi]);
        }

        // N번째 자리의 숫자 추출 위해 피제수 증가
        divfac *= 10;
    }
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<h2 data-ke-size="size26"><b>기수 정렬의 시간복잡도</b></h2>
<p data-ke-size="size16">기수 정렬의 시간복잡도는 비교 연산이 아닌 데이터의 삽입과 추출로 결정된다.</p>
<p data-ke-size="size16">버킷에 데이터를 넣고 빼는 연산은&nbsp;<b>최대 데이터의 길이 L x 데이터의 수 N </b>만큼 반복된다.&nbsp;</p>
<p data-ke-size="size16">따라서 시간 복잡도는 O(L*N)인데 L을 제거하면 <b>기수 정렬의 시간 복잡도는 O(N)이다.</b></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">결론적으로 기수 정렬은 사용할수 있는 경우가 매우 제한적이지만 기존까지의 정렬 알고리즘의 O(N*logN) 보다 훨씬 빠른 성능을 보인다.</p>
                        </div>
                        <br/>
                        <div class="tags">
                            #자료구조 #C #radix sort #기수 정렬 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
