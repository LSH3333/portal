
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>백준 2116. 주사위 쌓기</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">백준 2116. 주사위 쌓기</h2>
                                <div class="box-info">
                                    <p class="category">PS</p>
                                    <p class="date">2021-08-03 15:28:10</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p data-ke-size="size16"><a href="https://www.acmicpc.net/problem/2116" target="_blank" rel="noopener">https://www.acmicpc.net/problem/2116</a></p>
<figure id="og_1627971702009" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="2116번: 주사위 쌓기" data-og-description="첫줄에는 주사위의 개수가 입력된다. 그 다음 줄부터는 한 줄에 하나씩 주사위의 종류가 1번 주사위부터 주사위 번호 순서대로 입력된다. 주사위의 종류는 각 면에 적혀진 숫자가 그림1에 있는 " data-og-host="www.acmicpc.net" data-og-source-url="https://www.acmicpc.net/problem/2116" data-og-url="https://www.acmicpc.net/problem/2116" data-og-image="https://scrap.kakaocdn.net/dn/bJOmQ4/hyK6unPJPp/pX4CvbTqyNeA2xT1a3b3Qk/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630"><a href="https://www.acmicpc.net/problem/2116" target="_blank" rel="noopener" data-source-url="https://www.acmicpc.net/problem/2116">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/bJOmQ4/hyK6unPJPp/pX4CvbTqyNeA2xT1a3b3Qk/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630');">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">2116번: 주사위 쌓기</p>
<p class="og-desc" data-ke-size="size16">첫줄에는 주사위의 개수가 입력된다. 그 다음 줄부터는 한 줄에 하나씩 주사위의 종류가 1번 주사위부터 주사위 번호 순서대로 입력된다. 주사위의 종류는 각 면에 적혀진 숫자가 그림1에 있는</p>
<p class="og-host" data-ke-size="size16">www.acmicpc.net</p>
</div>
</a></figure>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">그렇게 어렵지 않은 문제인데 주사위의 면 인덱스를 어떻게 처리할지 햇갈려서 상당히 시간이 걸린 문제이다.</p>
<p data-ke-size="size16">육면체인 주사위의 아랫면,윗면만 신경쓰고 나머지 옆면들은 돌릴수있기 때문에 신경끄면 되는데 너무 어렵게 생각한것 같다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">일단 아랫면을 정했을때 윗면의 번호를 알수있어야 한다.</p>
<p data-ke-size="size16">따라서 입력을 받을때 <b>012345</b> 순으로 주어지는데 <b>012453</b> 으로 저장한다.</p>
<p data-ke-size="size16">예를들어 주어진 입력이 <b>2<span> </span>3<span> </span>1<span> </span>6<span> </span>5<span> </span>4</b>라면<b> 2 3 1 5 4 6</b>으로 저장한다.</p>
<p data-ke-size="size16">이렇게 하면 <b>현재면의 반대면 = (현재면+3) % 6</b> 이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">그 후에는 옆면들은 자유롭게 돌릴수 있기 때문에</p>
<p data-ke-size="size16">맨 아래 주사위의 아랫면,윗면만 바꾸면서 하나의 주사위의 옆면 중 최댓값을 더해나간 값 중에 최대값이 답이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1627972081053" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
using namespace std;

int n;
int ans = 0;
int dice[10001][6];

int main()
{
    cin &gt;&gt; n;
    // i번째 면의 반대면 = (i+3) % 6
    // (0,3), (1,4), (2,5)가 서로 반대 면
    for (int i = 0; i &lt; n; i++) {
        cin &gt;&gt; dice[i][0] &gt;&gt; dice[i][1] &gt;&gt; dice[i][2] &gt;&gt; dice[i][4] &gt;&gt; dice[i][5] &gt;&gt; dice[i][3];
    }

    // 첫번째 주사위의 아랫면이 dice[0][0]일때, dice[0][1]일때, ...
    for(int bottom = 0; bottom &lt; 6; bottom++)
    {
        int bot_idx = bottom;
        int sum = 0;

        for(int cnt = 0; cnt &lt; n; cnt++)
        {
            // 현재 주사위의 윗면의 인덱스
            int top_idx = (bot_idx+3)%6;
            int side_max = 0;
            // 옆면들중 가장 큰 수를 더함
            for(int i = 0; i &lt; 6; i++)
            {
                if(i == bot_idx || i == top_idx) continue;
                side_max = max(side_max, dice[cnt][i]);
            }
            sum += side_max;

            // 다음 주사위의 아랫면을 찾는다, 현재 마지막 주사위라면 찾지 않는다
            if(cnt == n-1) continue;
            for(int i = 0; i &lt; 6; i++)
            {
                // 현재 주사위의 윗면의 수가 다음 주사위의 아랫면의 수
                if(dice[cnt+1][i] == dice[cnt][top_idx])
                {
                    bot_idx = i;
                    break;
                }
            }
        }
        // 최댓값 갱신
        ans = max(ans, sum);
    }

    cout &lt;&lt; ans;
}</code></pre>
                        </div>
                        <br/>
                        <div class="tags">
                            #C++ #Brute Force 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
