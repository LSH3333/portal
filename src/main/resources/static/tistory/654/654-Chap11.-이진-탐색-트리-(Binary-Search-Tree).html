
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>Chap11. 이진 탐색 트리 (Binary Search Tree)</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">Chap11. 이진 탐색 트리 (Binary Search Tree)</h2>
                                <div class="box-info">
                                    <p class="category">윤성우의 열혈 자료구조</p>
                                    <p class="date">2022-04-16 17:23:16</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p data-ke-size="size16">이진 트리의 높이는 데이터의 갯수가 N일때 logN이기 때문에 데이터의 갯수가 10억개여도 트리의 높이는 30 정도 이다.</p>
<p data-ke-size="size16">따라서 탐색에 효율적이라는 것을 알수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><b>이진 탐색 트리&nbsp;</b></h2>
<p data-ke-size="size16"><b>이진 탐색 트리:</b></p>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img.png"  />
    </span>
    <figcaption>https://en.wikipedia.org/wiki/Binary_search_tree</figcaption>
</figure></p>
<p data-ke-size="size16">이진 탐색 트리는 이진 트리에 데이터를 저장하는 규칙들을 추가한 것이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>이진 탐색 트리 되기 위한 조건&nbsp;</b></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>이진 탐색 트리의 노드에 저장된 key는 유일하다&nbsp;</li>
<li>루트 노드의 키가 왼쪽 서브트리를 구성하는 어떠한 노드의 키보다 크다&nbsp;</li>
<li>루트 노드의 키가 오른쪽 서브트리를 구성하는 어떠한 노드의 키보다 작다&nbsp;</li>
<li>왼쪽과 오른쪽 서브트리도 이진 탐색 트리이다&nbsp;</li>
</ul>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>이진 탐색트리에서 항상 만족하는 조건</b></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>왼쪽 자식 노드의 키 &lt; 부모 노드의 키 &lt; 오른쪽 자식 노드의 키&nbsp;</li>
</ul>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이런 규칙 때문에 데이터를 <b>삽입할때는</b> 루트 노드에서부터 비교해가며 삽입하는 데이터가 더 작으면 왼쪽으로, 크면 오른쪽으로 이동해가며 자리를 찾으면 되고, <b>탐색할때도</b> 마찬가지이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<h2 data-ke-size="size26"><b>문제 11-1 [이진 탐색 트리의 조건]</b></h2>
<p data-ke-size="size16">이진 탐색 트리의 조건 중 다음 조건이 있다.</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>루트 노드의 키가 왼쪽 서브트리를 구성하는 어떠한 노드의 키보다 크다&nbsp;</li>
<li>루트 노드의 키가 오른쪽 서브트리를 구성하는 어떠한 노드의 키보다 작다&nbsp;</li>
</ul>
<p data-ke-size="size16">또한 이진 탐색 트리에서는 다음 조건이 항상 만족한다고 했다&nbsp;</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>왼쪽 자식 노드의 키 &lt; 부모 노드의 키 &lt; 오른쪽 자식 노드의 키&nbsp;</li>
</ul>
<p data-ke-size="size16">그렇다면 <b>위의 이진 탐색 트리의 두 조건을 다음과 같이 바꾸면 안되는 이유가 무엇일까?&nbsp;</b></p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li>부모 노드의 키가 왼쪽 자식 노드의 키보다 크다</li>
<li>부모 노드의 키가 오른쪽 자식 노드의 키보다 작다&nbsp;</li>
</ul>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">다음 트리를 보면 알 수 있다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 12</b></p>
<p data-ke-size="size16"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</b></p>
<p data-ke-size="size16"><b>&nbsp; &nbsp; &nbsp; &nbsp;9</b></p>
<p data-ke-size="size16"><b>&nbsp; &nbsp; /&nbsp; &nbsp; &nbsp; \</b></p>
<p data-ke-size="size16"><b>&nbsp; 4&nbsp; &nbsp; &nbsp; &nbsp; 18</b></p>
<p data-ke-size="size16"><b>&nbsp;/&nbsp; &nbsp;\</b></p>
<p data-ke-size="size16"><b>2&nbsp; 21</b></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">위 트리는 어느 위치에서든 부모 노드의 키가 왼쪽 자식 노드의 키보다 크고, 오른쪽 자식의 키보다 작다.</p>
<p data-ke-size="size16"><b>하지만 루트 노드인 12 보다 큰 값이 왼쪽 서브트리에 존재한다. (18, 21)</b></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<h2 data-ke-size="size26"><b>이진 탐색 트리 구현&nbsp;</b></h2>
<h4 data-ke-size="size20"><b>삽입&nbsp;</b></h4>
<p data-ke-size="size16">삽입할때는 이진 탐색 트리의 조건에 따라 루트 노드에서부터 삽입되는 노드의 위치를 찾아가면 된다.</p>
<p data-ke-size="size16">즉 새로운 노드의 값이 현재 위치의 노드의 값 보다 작으면 왼쪽, 크면 오른쪽으로 이동하면서 새로운 노드가 삽입될 위치를 찾아서 삽입한다. 이때 키의 중복은 허용하지 않는다.</p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><b>탐색</b></h4>
<p data-ke-size="size16">탐색도 삽입과 똑같은 논리이다.</p>
<p data-ke-size="size16">루트 노드에서부터 찾는 데이터의 값이 현재 위치 노드의 값보다 작으면 왼쪽으로 크면 오른쪽으로 이동하면서 찾는다.</p>
<p data-ke-size="size16">이렇게 점점 트리 깊숙히 이동하다가 NULL을 만난다면 내가 찾는 데이터가 트리에 없다는 뜻이다.&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><b>삭제</b></h4>
<p data-ke-size="size16">이진 탐색 트리에서 삭제는 삽입과 탐색과 달리 까다롭다.&nbsp;</p>
<p data-ke-size="size16">왜냐하면 <b>노드의 삭제 이후에도 이진 탐색 트리의 조건들이 유지되어야 하기 때문이다.&nbsp;</b></p>
<p data-ke-size="size16">특정 노드를 삭제를 하는 경우를 생각해보면 다음과 같은 경우가 있을 것이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<ul style="list-style-type: disc;" data-ke-list-type="disc">
<li><b>상황 1 : 삭제할 노드가 단말 노드인 경우&nbsp;</b></li>
<li><b>상황 2 : 삭제할 노드가 하나의 자식 노드를 갖는 경우 (하나의 서브트리)&nbsp;</b></li>
<li><b>상황 3 : 삭제할 노드가 두개의 자식 노드를 갖는 경우 (두개의 서브트리)&nbsp;</b></li>
</ul>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b><u>상황1&nbsp;</u>&nbsp;</b>의 경우 단말노드이기 때문에 자식이 없는 경우이다.&nbsp;</p>
<p data-ke-size="size16">이 경우 그냥 단말노드를 삭제해버리면 그만이다.&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><u><b>상황2&nbsp;</b></u>의 <b>경우 삭제 되는 노드의 부모 노드와 자식 노드를 연결한다.&nbsp;</b></p>
<p data-ke-size="size16">다음과 같은 트리에서 9가 담긴 노드를 삭제한다고 생각해보자.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>8</b></p>
<p data-ke-size="size16"><b>&nbsp; &nbsp; \</b></p>
<p data-ke-size="size16"><b>&nbsp; &nbsp; &nbsp; 9</b></p>
<p data-ke-size="size16"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\</b></p>
<p data-ke-size="size16"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10</b></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">9를 삭제하고 8의 오른쪽 자식 노드가 10이 되도록 하면 될것이다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>8</b></p>
<p data-ke-size="size16"><b>&nbsp; &nbsp;\&nbsp;</b></p>
<p data-ke-size="size16"><b>&nbsp; &nbsp; 10&nbsp;</b></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">여기서 기억해야 할 것은 10이 저장된 노드가 9의 오른쪽 노드이건 왼쪽 노드이건 상관 없이, 9가 삭제된 이후에 8의 오른쪽 자식 노드가 되어야 한다는 것이다. 생각해보면 삭제 이전 10이 9의 왼쪽 노드였더라도 8 입장에서 보면 오른쪽 서브 트리에 해당한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><u><b>상황3</b></u> &nbsp;</p>
<p data-ke-size="size16">상황3은 삭제할 노드가 두 개의 서브 트리를 갖는 경우인데 이 경우가 좀 까다롭다.</p>
<p data-ke-size="size16">우선 다음 트리를 보자.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;12</b></p>
<p data-ke-size="size16"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /&nbsp; &nbsp; &nbsp; &nbsp;\</b></p>
<p data-ke-size="size16"><b>&nbsp; &nbsp; &nbsp; &nbsp; <u>8</u></b></p>
<p data-ke-size="size16"><b>&nbsp; &nbsp; &nbsp; &nbsp;/&nbsp; \</b></p>
<p data-ke-size="size16"><b>&nbsp; &nbsp; 4&nbsp; &nbsp; &nbsp;9</b></p>
<p data-ke-size="size16"><b>&nbsp; /&nbsp; \&nbsp; &nbsp; &nbsp; &nbsp; \</b></p>
<p data-ke-size="size16"><b>2&nbsp; &nbsp; 7&nbsp; &nbsp; &nbsp; &nbsp;10</b></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">위 트리에서 8이 담긴 노드를 삭제했을때도 이진 탐색 트리의 조건들이 유지되려면 어떻게 해야할까.</p>
<p data-ke-size="size16"><b>8의 왼쪽 서브 트리 중 가장 큰값 7과 오른쪽 서브 트리 중 가장 작은 값 9와 대체 하면 된다.&nbsp;</b>&nbsp;</p>
<p data-ke-size="size16">이 두 경우 모두 노드 삭제 이후에도 이진 탐색 트리의 조건이 유지 가능하다.</p>
<p data-ke-size="size16">따라서 오른쪽 서브 트리 중 가장 작은 값과 대체하기로 하겠다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">대체 하는 방법은 다음과 같다.</p>
<p data-ke-size="size16">1. 삭제할 노드를 대체할 노드를 찾는다. // 위 트리에서는 9&nbsp;</p>
<p data-ke-size="size16">2. 대체할 노드에 저장된 값을 삭제할 노드에 대입한다. // 위 트리에서 8이 9가 된다&nbsp;</p>
<p data-ke-size="size16">3. 대체할 노드의 부모 노드와 자식 노드를 연결한다. // 원래 9가 있던 노드는 삭제되고, 원래 8이 였던 노드의 오른쪽 자식 노드가 10이 된다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><b>이진 탐색 트리 구현을 위해 이진 트리 헤더에 추가해야할 함수들&nbsp;</b></h4>
<pre class="c++ arduino" data-ke-language="c++"><code>// 이진 탐색 트리를 위한 함수들
// 왼쪽 자식 노드를 트리에서 제거, 제거된 노드 주소값 반환
BTreeNode *RemoveLeftSubTree(BTreeNode *bt);
BTreeNode *RemoveRightSubTree(BTreeNode *bt);
// 메모리 소멸을 수반하지 않고 main의 왼쪽 자식 노드를 sub 노드로 변경
void ChangeLeftSubTree(BTreeNode *main, BTreeNode *sub);
void ChangeRightSubTree(BTreeNode *main, BTreeNode *sub);</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><b>구현</b></h4>
<p data-ke-size="size16">BinaryTraversalTree.h 는 이진 트리 구현의 헤더이고, BinarySearchTree.h 는 이진 탐색 트리의 헤더이다.</p>
<p data-ke-size="size16">이진 탐색트리는 이진 트리를 이용해서 구현한다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>BinaryTraversalTree.h</b></p>
<pre class="armasm"><code>/*
 * 이진 트리 순회 함수 포함하는 연결 리스트 기반 이진트리 구현
 */

#ifndef CHAP08_BINARYTREETRAVERSAL_BINARYTREETRAVERSAL_H
#define CHAP08_BINARYTREETRAVERSAL_BINARYTREETRAVERSAL_H

typedef int BTData;

typedef struct _bTreeNode
{
    BTData data;
    struct _bTreeNode *left;
    struct _bTreeNode *right;
} BTreeNode;

BTreeNode *MakeBTreeNode();
BTData GetData(BTreeNode *bt);
void SetData(BTreeNode *bt, BTData data);

BTreeNode *GetLeftSubTree(BTreeNode *bt);
BTreeNode *GetRightSubTree(BTreeNode *bt);

void MakeLeftSubTree(BTreeNode *main, BTreeNode *sub);
void MakeRightSubTree(BTreeNode *main, BTreeNode *sub);

// func pointer
typedef void (*VisitFuncPtr)(BTData data);

// 순회
void PreorderTraverse(BTreeNode *bt, VisitFuncPtr action);
void InorderTraverse(BTreeNode *bt, VisitFuncPtr action);
void PostorderTraverse(BTreeNode *bt, VisitFuncPtr action);

// 순회하며 메모리 해제
void DeleteTree(BTreeNode *bt);

// 이진 탐색 트리를 위한 함수들
// 왼쪽 자식 노드를 트리에서 제거, 제거된 노드 주소값 반환
BTreeNode *RemoveLeftSubTree(BTreeNode *bt);
BTreeNode *RemoveRightSubTree(BTreeNode *bt);
// 메모리 소멸을 수반하지 않고 main의 왼쪽 자식 노드를 sub 노드로 변경
void ChangeLeftSubTree(BTreeNode *main, BTreeNode *sub);
void ChangeRightSubTree(BTreeNode *main, BTreeNode *sub);

#endif //CHAP08_BINARYTREETRAVERSAL_BINARYTREETRAVERSAL_H
</code></pre>
<p data-ke-size="size16"><b>BinaryTraversalTree.c</b></p>
<pre class="armasm"><code>
#include "BinaryTreeTraversal.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

BTreeNode * MakeBTreeNode()
{
    BTreeNode *nd = (BTreeNode*)malloc(sizeof(BTreeNode));
    nd-&gt;left = NULL;
    nd-&gt;right = NULL;
    return nd;
}

BTData GetData(BTreeNode *bt)
{
    return bt-&gt;data;
}

void SetData(BTreeNode *bt, BTData data)
{
    bt-&gt;data = data;
}

BTreeNode *GetLeftSubTree(BTreeNode *bt)
{
    return bt-&gt;left;
}

BTreeNode *GetRightSubTree(BTreeNode *bt)
{
    return bt-&gt;right;
}

void MakeLeftSubTree(BTreeNode *main, BTreeNode *sub)
{
    // main 트리의 left child가 이미 존재한다면 삭제하고 연결
    // 이 경우, 삭제되는 트리가 여러개의 노드로 이뤄져 있다면 메모리 누수가 발생한다
    if(main-&gt;left != NULL)
        free(main-&gt;left);

    main-&gt;left = sub;
}

void MakeRightSubTree(BTreeNode *main, BTreeNode *sub)
{
    if(main-&gt;right != NULL)
        free(main-&gt;right);

    main-&gt;right = sub;
}

void PreorderTraverse(BTreeNode *bt, VisitFuncPtr action)
{
    if(bt == NULL) return;

    action(bt-&gt;data);
    PreorderTraverse(bt-&gt;left, action);
    PreorderTraverse(bt-&gt;right, action);
}

void InorderTraverse(BTreeNode *bt, VisitFuncPtr action)
{
    if(bt == NULL) return;

    InorderTraverse(bt-&gt;left, action);
    action(bt-&gt;data);
    InorderTraverse(bt-&gt;right, action);
}

void PostorderTraverse(BTreeNode *bt, VisitFuncPtr action)
{
    if(bt == NULL) return;

    PostorderTraverse(bt-&gt;left, action);
    PostorderTraverse(bt-&gt;right, action);
    action(bt-&gt;data);
}

void DeleteTree(BTreeNode *bt)
{
    if(bt == NULL) return;
    DeleteTree(bt-&gt;left);
    DeleteTree(bt-&gt;right);
    free(bt);
}

void ChangeLeftSubTree(BTreeNode *main, BTreeNode *sub)
{
    main-&gt;left = sub;
}

void ChangeRightSubTree(BTreeNode *main, BTreeNode *sub)
{
    main-&gt;right = sub;
}

BTreeNode *RemoveLeftSubTree(BTreeNode *bt)
{
    BTreeNode *delNode;

    if(bt != NULL)
    {
        delNode = bt-&gt;left;
        bt-&gt;left = NULL;
    }
    return delNode;
}

BTreeNode *RemoveRightSubTree(BTreeNode *bt)
{
    BTreeNode *delNode;

    if(bt != NULL)
    {
        delNode = bt-&gt;right;
        bt-&gt;right = NULL;
    }
    return delNode;
}</code></pre>
<p data-ke-size="size16"><b>BinarySearchTree.h</b></p>
<pre class="cpp"><code>/*
 * 이진 탐색 트리 (Binary Search Tree)
 */
#ifndef CHAP11_BINARYSEARCHTREE_BINARYSEARCHTREE_H
#define CHAP11_BINARYSEARCHTREE_BINARYSEARCHTREE_H

#include "BinaryTreeTraversal.h"

typedef BTData BSTData;

// BST 생성 및 초기화
void BSTMakeAndInit(BTreeNode **pRoot);

// 노드에 저장된 데이터 반환
BSTData BSTGetNodeData(BTreeNode *bst);

// BST를 대상으로 데이터 저장 (노드의 생성과정 포함)
void BSTInsert(BTreeNode **pRoot, BSTData data);

// BST를 대상으로 데이터 탐색
BTreeNode *BSTSearch(BTreeNode *bst, BSTData target);


// 트리에서 노드를 제거하고 제거된 노드의 주소 값을 반환
BTreeNode *BSTRemove(BTreeNode **pRoot, BSTData target);

// 이진 탐색 트리에 저장된 모든 노드의 데이터를 출력
void BSTShowAll(BTreeNode *bst);

#endif //CHAP11_BINARYSEARCHTREE_BINARYSEARCHTREE_H
</code></pre>
<p data-ke-size="size16"><b>BinarySearchTree.c</b></p>
<pre class="armasm"><code>
#include "BinaryTreeTraversal.h"
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

BTreeNode * MakeBTreeNode()
{
    BTreeNode *nd = (BTreeNode*)malloc(sizeof(BTreeNode));
    nd-&gt;left = NULL;
    nd-&gt;right = NULL;
    return nd;
}

BTData GetData(BTreeNode *bt)
{
    return bt-&gt;data;
}

void SetData(BTreeNode *bt, BTData data)
{
    bt-&gt;data = data;
}

BTreeNode *GetLeftSubTree(BTreeNode *bt)
{
    return bt-&gt;left;
}

BTreeNode *GetRightSubTree(BTreeNode *bt)
{
    return bt-&gt;right;
}

void MakeLeftSubTree(BTreeNode *main, BTreeNode *sub)
{
    // main 트리의 left child가 이미 존재한다면 삭제하고 연결
    // 이 경우, 삭제되는 트리가 여러개의 노드로 이뤄져 있다면 메모리 누수가 발생한다
    if(main-&gt;left != NULL)
        free(main-&gt;left);

    main-&gt;left = sub;
}

void MakeRightSubTree(BTreeNode *main, BTreeNode *sub)
{
    if(main-&gt;right != NULL)
        free(main-&gt;right);

    main-&gt;right = sub;
}

void PreorderTraverse(BTreeNode *bt, VisitFuncPtr action)
{
    if(bt == NULL) return;

    action(bt-&gt;data);
    PreorderTraverse(bt-&gt;left, action);
    PreorderTraverse(bt-&gt;right, action);
}

void InorderTraverse(BTreeNode *bt, VisitFuncPtr action)
{
    if(bt == NULL) return;

    InorderTraverse(bt-&gt;left, action);
    action(bt-&gt;data);
    InorderTraverse(bt-&gt;right, action);
}

void PostorderTraverse(BTreeNode *bt, VisitFuncPtr action)
{
    if(bt == NULL) return;

    PostorderTraverse(bt-&gt;left, action);
    PostorderTraverse(bt-&gt;right, action);
    action(bt-&gt;data);
}

void DeleteTree(BTreeNode *bt)
{
    if(bt == NULL) return;
    DeleteTree(bt-&gt;left);
    DeleteTree(bt-&gt;right);
    free(bt);
}

void ChangeLeftSubTree(BTreeNode *main, BTreeNode *sub)
{
    main-&gt;left = sub;
}

void ChangeRightSubTree(BTreeNode *main, BTreeNode *sub)
{
    main-&gt;right = sub;
}

BTreeNode *RemoveLeftSubTree(BTreeNode *bt)
{
    BTreeNode *delNode;

    if(bt != NULL)
    {
        delNode = bt-&gt;left;
        bt-&gt;left = NULL;
    }
    return delNode;
}

BTreeNode *RemoveRightSubTree(BTreeNode *bt)
{
    BTreeNode *delNode;

    if(bt != NULL)
    {
        delNode = bt-&gt;right;
        bt-&gt;right = NULL;
    }
    return delNode;
}</code></pre>
<p data-ke-size="size16"><b>BinarySearchTreeMain.c</b></p>
<pre class="reasonml"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include "BinarySearchTree.h"

int main()
{
    BTreeNode *bstRoot;
    BTreeNode *sNode;

    BSTMakeAndInit(&amp;bstRoot);

    BSTInsert(&amp;bstRoot, 5);
    BSTInsert(&amp;bstRoot, 8);
    BSTInsert(&amp;bstRoot, 1);
    BSTInsert(&amp;bstRoot, 6);
    BSTInsert(&amp;bstRoot, 4);
    BSTInsert(&amp;bstRoot, 9);
    BSTInsert(&amp;bstRoot, 3);
    BSTInsert(&amp;bstRoot, 2);
    BSTInsert(&amp;bstRoot, 7);

    // 노드 하나씩 제거하면서 노드 중위 순회해서 출력
    BSTShowAll(bstRoot); printf("\n");
    sNode = BSTRemove(&amp;bstRoot, 3);
    free(sNode);

    BSTShowAll(bstRoot); printf("\n");
    sNode = BSTRemove(&amp;bstRoot, 8);
    free(sNode);

    BSTShowAll(bstRoot); printf("\n");
    sNode = BSTRemove(&amp;bstRoot, 1);
    free(sNode);

    BSTShowAll(bstRoot); printf("\n");
    sNode = BSTRemove(&amp;bstRoot, 6);
    free(sNode);

    BSTShowAll(bstRoot); printf("\n");
}</code></pre>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
                        </div>
                        <br/>
                        <div class="tags">
                            #C #Binary Search Tree #이진 탐색 트리 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
