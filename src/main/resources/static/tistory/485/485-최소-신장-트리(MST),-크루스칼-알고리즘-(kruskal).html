
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>최소 신장 트리(MST), 크루스칼 알고리즘 (kruskal)</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">최소 신장 트리(MST), 크루스칼 알고리즘 (kruskal)</h2>
                                <div class="box-info">
                                    <p class="category">알고리즘</p>
                                    <p class="date">2022-01-18 14:40:24</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p data-ke-size="size16">학교에서 배웠었는데 알고리즘 문제에 필요해서 다시 한번 정리.&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">Union-Find 알고리즘 : (<a href="https://tose33.tistory.com/614" target="_blank" rel="noopener">https://tose33.tistory.com/614</a>)</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><b>- 크루스칼 알고리즘&nbsp;</b></h2>
<p data-ke-size="size16">최소의 비용으로 모든 노드를 연결하는 알고리즘</p>
<h2 data-ke-size="size26"><b>- 신장 트리 (Spanning Tree)</b></h2>
<p data-ke-size="size16">1) 그래프의 모든 정점을 포함</p>
<p data-ke-size="size16">2) 싸이클을 형성하지 않음&nbsp; -&gt; 이 조건에 의해 정점의 갯수가 n개 일때, 간선의 갯수는 무조건 n-1개&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><b>- 최소 신장 트리 (Minimum Spanning Tree, MST)&nbsp;</b></h2>
<p data-ke-size="size16">신장 트리이면서 가중치(간선)의 합이 최소가 되는 트리&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><b>- 최소 신장 트리 구하는 방법&nbsp;</b></h2>
<p data-ke-size="size16">1. 간선들의 가중치를 기준으로 오름차순 정렬한다&nbsp;</p>
<p data-ke-size="size16">2. 가중치가 작은 간선부터 사이클을 형성하지 않는다면 잇는다&nbsp;</p>
<p data-ke-size="size16">3. 간선의 갯수가 정점의갯수-1개가 됐다면 최소 신장 트리 완성&nbsp;</p>
<h2 data-ke-size="size26">&nbsp;</h2>
<h2 data-ke-size="size26"><b>- 사이클을 형성 하는지 아닌지 판단법&nbsp;</b></h2>
<p data-ke-size="size16">-&gt; 각 정점의 부모 정점이 같다면 싸이클.</p>
<p data-ke-size="size16">최초에 각 정점은 자기 자신을 부모 정점으로 갖는다.</p>
<p data-ke-size="size16">작은 가중치를 갖는 간선부터 잇는데 잇는 두 정점의 부모가 같다면 사이클 이므로 잇지 않는다.&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<script src="https://gist.github.com/LSH3333/1f145f14870055898a4c8f43f90f83dc.js"></script>
<p data-ke-size="size16">FindParentNode에서 재귀적으로 부모 노드를 찾는데, return 문에서 <b>parentNode[node] = FindParentNode(parentNode[node])&nbsp;</b>이런 식으로 재귀하면서 값을 저장해줘야 시간을 줄일수 있다.&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p><figure class="imageblock alignLeft" >
    <span data-lightbox="lightbox">
        <img src="./img/img.png"  />
    </span>
    <figcaption></figcaption>
</figure></p>
<p data-ke-size="size16"><s>최종적으로 parentNode는 모두 0이 된다.&nbsp;</s></p>
<p data-ke-size="size16"><s>모두 0 노드를 부모(루트) 노드로 갖게된다.&nbsp;</s></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h2 data-ke-size="size26"><b>크루스칼 알고리즘으로 MST가 성공적으로 만들어졌는지 판별&nbsp;</b></h2>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>2022.05.21&nbsp;</b></p>
<p data-ke-size="size16"><a href="https://www.acmicpc.net/problem/17472" target="_blank" rel="noopener">https://www.acmicpc.net/problem/17472</a></p>
<figure id="og_1653115980502" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="17472번: 다리 만들기 2" data-og-description="첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. 둘째 줄부터 N개의 줄에 지도의 정보가 주어진다. 각 줄은 M개의 수로 이루어져 있으며, 수는 0 또는 1이다. 0은 바다, 1은 땅을 의미한다." data-og-host="www.acmicpc.net" data-og-source-url="https://www.acmicpc.net/problem/17472" data-og-url="https://www.acmicpc.net/problem/17472" data-og-image="https://scrap.kakaocdn.net/dn/NvyO6/hyOteh4m5o/P6wT49kag9T7M4oaWZVcSK/img.png?width=2834&amp;height=1480&amp;face=0_0_2834_1480,https://scrap.kakaocdn.net/dn/bOMHCf/hyOs4fuqkd/JcwvPkCMeUbkHL3vC6KSZk/img.jpg?width=1022&amp;height=908&amp;face=0_0_1022_908,https://scrap.kakaocdn.net/dn/biSAfc/hyOuakQGnm/oPMtjI4Ptlp56hHaRkjnn1/img.jpg?width=1016&amp;height=902&amp;face=0_0_1016_902"><a href="https://www.acmicpc.net/problem/17472" target="_blank" rel="noopener" data-source-url="https://www.acmicpc.net/problem/17472">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/NvyO6/hyOteh4m5o/P6wT49kag9T7M4oaWZVcSK/img.png?width=2834&amp;height=1480&amp;face=0_0_2834_1480,https://scrap.kakaocdn.net/dn/bOMHCf/hyOs4fuqkd/JcwvPkCMeUbkHL3vC6KSZk/img.jpg?width=1022&amp;height=908&amp;face=0_0_1022_908,https://scrap.kakaocdn.net/dn/biSAfc/hyOuakQGnm/oPMtjI4Ptlp56hHaRkjnn1/img.jpg?width=1016&amp;height=902&amp;face=0_0_1016_902');">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">17472번: 다리 만들기 2</p>
<p class="og-desc" data-ke-size="size16">첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. 둘째 줄부터 N개의 줄에 지도의 정보가 주어진다. 각 줄은 M개의 수로 이루어져 있으며, 수는 0 또는 1이다. 0은 바다, 1은 땅을 의미한다.</p>
<p class="og-host" data-ke-size="size16">www.acmicpc.net</p>
</div>
</a></figure>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이 문제를 풀다가 잘못된 점을 수정한다.&nbsp;</p>
<p data-ke-size="size16">위에서 최종적으로 parentNode 배열은 모두 가장 작은 노드값인 0을 갖게 된다고 했었는데 틀렸다.</p>
<p data-ke-size="size16"><b>부모 노드의 판별은 재귀적으로 그떄그때 판단하기 때문에, 모든 노드들이 연결된 MST가 완성된다고 하더라도 최종적으로 parentNode 배열이 모두 같은 값이 되지는 않는다.</b></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">예를들어 아래와 같은 그래프가 MST가 있다고 하자.&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>1 ---- 2 ---- 3</b></p>
<p data-ke-size="size16"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; |</b></p>
<p data-ke-size="size16"><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4&nbsp;</b></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이때 최종적으로 <b>parentNode[] 배열</b>은 다음과 같이 된다&nbsp;</p>
<table style="border-collapse: collapse; width: 49.4186%; height: 61px;" border="1" data-ke-align="alignLeft">
<tbody>
<tr>
<td style="width: 20%;"><b>Node:</b></td>
<td style="width: 20%;"><b>1</b></td>
<td style="width: 20%;"><b>2</b></td>
<td style="width: 20%;"><b>3</b></td>
<td style="width: 20%;"><b>4</b></td>
</tr>
<tr>
<td style="width: 20%;"><b>Parent:</b></td>
<td style="width: 20%;"><b>1</b></td>
<td style="width: 20%;"><b>1</b></td>
<td style="width: 20%;"><b>2</b></td>
<td style="width: 20%;"><b>2</b></td>
</tr>
</tbody>
</table>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">노드4의 부모를 판별할땐 재귀적으로 노드4의 부모노드인 2로가고 2의 부모노드인 1로 가기 때문에,&nbsp;</p>
<p data-ke-size="size16">노드 4의 부모노드는 1이다.&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">따라서 <b>크루스칼 알고리즘으로 최소 스패닝 트리 만들기를 시도했을때 성공했는지 여부는 parentNode 배열이 모두 같은 값인지로 판단하는 것이 아닌</b> (내가 이렇게해서 틀림) 두 노드를 잇는 Union 과정이 몇번 일어나는지를 계산한후에,&nbsp;</p>
<p data-ke-size="size16"><b>Union 횟수 +1 = 총 노드의 갯수&nbsp;</b>여야 MST가 성공적으로 만들어 진 것이다.&nbsp;</p>
<p data-ke-size="size16">(정확히 말하면 최종적으로 간선의 갯수는 노드의 갯수보다 하나 적어야 한다)&nbsp;</p>
                        </div>
                        <br/>
                        <div class="tags">
                            #C++ #MST #최소 신장 트리 #Kruskal Algorithm 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
