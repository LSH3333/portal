
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>2667. 단지번호붙이기</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">2667. 단지번호붙이기</h2>
                                <div class="box-info">
                                    <p class="category">PS</p>
                                    <p class="date">2020-08-18 20:58:33</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p><a href="https://www.acmicpc.net/problem/2667">https://www.acmicpc.net/problem/2667</a></p>
<figure id="og_1597741333628" contenteditable="false" data-ke-type="opengraph" data-og-type="website" data-og-title="2667번: 단지번호붙이기" data-og-description="&lt;그림 1&gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집들의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. �" data-og-host="www.acmicpc.net" data-og-source-url="https://www.acmicpc.net/problem/2667" data-og-url="https://www.acmicpc.net/problem/2667" data-og-image="https://scrap.kakaocdn.net/dn/bngFlI/hyHa7CsjAC/kJjfiC5qtOHvYKXVRKDQ7k/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630"><a href="https://www.acmicpc.net/problem/2667" target="_blank" rel="noopener" data-source-url="https://www.acmicpc.net/problem/2667">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/bngFlI/hyHa7CsjAC/kJjfiC5qtOHvYKXVRKDQ7k/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630');">&nbsp;</div>
<div class="og-text">
<p class="og-title">2667번: 단지번호붙이기</p>
<p class="og-desc">&lt;그림 1&gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집들의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. �</p>
<p class="og-host">www.acmicpc.net</p>
</div>
</a></figure>
<p>&nbsp;</p>
<p>일단 입력을 받아야 되는데 자바를 배운지 얼마안되서 string을 나누는법 부터 찾아봤다.</p>
<p>&nbsp;</p>
<p>Scanner.next() : 공백 전까지 입력받은 문자열 리턴</p>
<p>Scanner.nextlint() : enter전까지 입력받은 문자열 리턴</p>
<p>&nbsp;</p>
<p>string.charAt(idx) : String에서 idx위치에 해당하는 문자 출력</p>
<p>ex) String str = "abcd"</p>
<p>&nbsp; &nbsp; &nbsp;char dat = str.charAt(0) // dat는 'a' 가 됨.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>문제는 지금까지처럼 dfs나 bfs문제랑 비슷한데 2차원 배열을 쓰는것이 다른점인것 같다.</p>
<p>&nbsp;</p>
<p>dfs 방식으로 풀었고, 지도를 저장할 배열 이외에도 방문 여부를 체크하는 배열이 필요하다.</p>
<p>&nbsp;</p>
<pre id="code_1597751373761" class="python" style="display: block; overflow: auto; padding: 15px; color: #383a42; background: #f6f7f8; font-size: 14px; border-radius: 3px; font-family: Menlo, Consolas, Monaco, monospace; border: 1px solid #dddddd; margin: 20px auto 0px; cursor: default; z-index: 1; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;" data-ke-language="python" data-ke-type="codeblock"><code>// 지도 저장중..
        for(int i = 0; i &lt; n; i++) {
            String temp = sc.next();

            for(int j = 0; j &lt; n; j++) {
                arr[i][j] = temp.charAt(j)-'0'; // string to int
            }
        }</code></pre>
<p>처음에 몰랐던 java에서 String한줄 입력받고 그것을 하나씩 나누는법.</p>
<p>Scanner.next(), str.CharAt() 사용.</p>
<pre id="code_1597751427143" class="java" data-ke-language="java" data-ke-type="codeblock"><code>for(int i = 0; i &lt; n; i++) {
            for(int j = 0; j &lt; n; j++) {
                // 방문하지 않았고, 집이 존재
                if(visit[i][j] == 0 &amp;&amp; arr[i][j] == 1) {
                    house_n = 0;
                    estate_num++;
                    dfs(i, j); // 여기서 dfs() 실행 수가 단지의 수.
                    house.push(house_n);
                }
            }
        }</code></pre>
<p>i,j를 루프하면서 arr[i][j] 좌표에 집이 존재하고 &amp;&amp; 아직 방문하지 않았으면 dfs 실행.</p>
<p>이때 dfs를 실행수가 단지의 수가 된다고 할수 있다.</p>
<p>그리고 dfs를 실행전에 그 단지의 집의 수 (house_n)을 0으로 초기화하고 dfs를 실행할때마다 1씩 더해서</p>
<p>dfs를 빠져나온 후의 house_n이 그 단지의 집의 총 갯수 이다.</p>
<p>&nbsp;</p>
<p>집을 발견하면 dfs를 실행하고 dfs가 다 실행된 후에는 같은 단지안의 집들은 모두 이미 방문 상태가 될것이다.</p>
<p>그래서 dfs한번을 돌면 한 단지가 모두 방문 상태가 되므로 다음 dfs탐색은 또 다른 단지에서만 시작된다.&nbsp;</p>
<p>&nbsp;</p>
<p>단지 안의 집의 수를 구할때 처음에는 stack을 쓰지않고 그냥 int[] 배열을 썼더니 런타임에러가 났다.</p>
<p>런타임에러라 함은 보통 잘못된 배열의 참조가 있을때 일어나는데.. 대충 어디일까 짐작은 되지만 못찾겠어서&nbsp;</p>
<p>그냥 Stack으로 고쳤더니 해결됐다.</p>
<p>&nbsp;</p>
<pre id="code_1597751636426" class="java" data-ke-language="java" data-ke-type="codeblock"><code>static void dfs(int a, int b) {
        visit[a][b] = 1; // 방문 체크
        //house[estate_num]++; // dfs가 실행될때마다 단지 idx에 따라 house의 수 증가
        house_n++;

        // 좌,우,상,하 이동
        if(b+1 &lt; n &amp;&amp; arr[a][b+1] == 1 &amp;&amp; visit[a][b+1] == 0) // 우
            dfs(a, b+1);
        if(b-1 &gt;= 0 &amp;&amp; arr[a][b-1] == 1 &amp;&amp; visit[a][b-1] == 0) // 좌
            dfs(a, b-1);
        if(a-1 &gt;= 0 &amp;&amp; arr[a-1][b] == 1 &amp;&amp; visit[a-1][b] == 0) // 상
            dfs(a-1, b);
        if(a+1 &lt; n &amp;&amp; arr[a+1][b] == 1 &amp;&amp; visit[a+1][b] == 0) // 하
            dfs(a+1, b);

    }</code></pre>
<p>현재 체크중인 집에서 좌,우,상,하 집을 봤을 때, 그 집이 존재하고 방문하지 않았으면 dfs실행.</p>
<p>&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<p><figure class="imageblock alignCenter" data-filename="20200818205637.png" data-origin-width="1378" data-origin-height="258" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img.png" data-filename="20200818205637.png" data-origin-width="1378" data-origin-height="258" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p>처음 이 문제를 열었을때 실패표시가 있어서 봤더니 알고보니 거의 1년전에 알고리즘이란 것을 거의 몰랐을때 시도해본 문제였다. 그 때 아무것도 모르고 풀었을때는 거의 손도 못 댔는데 이렇게 거의 1년이 지난 후 푸니까 뭔가 감회가 새롭다 ㅋㅋ.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><u>코드</u></p>
<div data-ke-type="moreLess" data-text-more="더보기" data-text-less="닫기">
<div class="moreless-content-ignore">
<pre id="code_1597751732959" class="java" data-ke-language="java" data-ke-type="codeblock"><code>import java.util.*;

public class Main {
    static int[][] arr; // 지도 저장
    static int[][] visit; // 방문 여부
    static Stack&lt;Integer&gt; house = new Stack&lt;Integer&gt;();
    static int house_n;
    static int n;
    static int estate_num = 0; // 단지수

    public static void main(String args[]) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();

        arr = new int[n][n];
        visit = new int[n][n];

        // 지도 저장중..
        for(int i = 0; i &lt; n; i++) {
            String temp = sc.next();

            for(int j = 0; j &lt; n; j++) {
                arr[i][j] = temp.charAt(j)-'0'; // string to int
            }
        }


        for(int i = 0; i &lt; n; i++) {
            for(int j = 0; j &lt; n; j++) {
                // 방문하지 않았고, 집이 존재
                if(visit[i][j] == 0 &amp;&amp; arr[i][j] == 1) {
                    house_n = 0;
                    estate_num++;
                    dfs(i, j); // 여기서 dfs() 실행 수가 단지의 수.
                    house.push(house_n);
                }
            }
        }

        System.out.println(estate_num);
        
        Collections.sort(house);
        for(int x : house) System.out.println(x);

    }

    static void dfs(int a, int b) {
        visit[a][b] = 1; // 방문 체크
        
        house_n++;

        // 좌,우,상,하 이동
        if(b+1 &lt; n &amp;&amp; arr[a][b+1] == 1 &amp;&amp; visit[a][b+1] == 0) // 우
            dfs(a, b+1);
        if(b-1 &gt;= 0 &amp;&amp; arr[a][b-1] == 1 &amp;&amp; visit[a][b-1] == 0) // 좌
            dfs(a, b-1);
        if(a-1 &gt;= 0 &amp;&amp; arr[a-1][b] == 1 &amp;&amp; visit[a-1][b] == 0) // 상
            dfs(a-1, b);
        if(a+1 &lt; n &amp;&amp; arr[a+1][b] == 1 &amp;&amp; visit[a+1][b] == 0) // 하
            dfs(a+1, b);

    }
}</code></pre>
</div>
</div>
<p>&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
<p><u>solution</u></p>
<p>&nbsp;</p>
<p>솔루션에서는 dfs를 이용한것도 있고, bfs를 이용한 방법도 있었다.</p>
<p>일단 dfs를 이용한 방법은 Flood Fill 알고리즘 이라고 한다고 한다.</p>
<p>바둑, 지뢰찾기나 그림판같은 곳에서 많이 쓰이는 알고리즘이라고 한다.</p>
<p>&nbsp;</p>
<p><u>dfs</u></p>
<p>코드 자체는 내가 한것과 거의 비슷했는데 한가지 다른것은 나는 dfs 탐색에서 다른 4방향으로 이동할때&nbsp;</p>
<pre id="code_1598347590104" class="java" data-ke-language="java" data-ke-type="codeblock"><code>// 좌,우,상,하 이동
        if(b+1 &lt; n &amp;&amp; arr[a][b+1] == 1 &amp;&amp; visit[a][b+1] == 0) // 우
            dfs(a, b+1);
        if(b-1 &gt;= 0 &amp;&amp; arr[a][b-1] == 1 &amp;&amp; visit[a][b-1] == 0) // 좌
            dfs(a, b-1);
        if(a-1 &gt;= 0 &amp;&amp; arr[a-1][b] == 1 &amp;&amp; visit[a-1][b] == 0) // 상
            dfs(a-1, b);
        if(a+1 &lt; n &amp;&amp; arr[a+1][b] == 1 &amp;&amp; visit[a+1][b] == 0) // 하
            dfs(a+1, b);</code></pre>
<p>이런식으로 일일히 이동했는데 솔루션에서는&nbsp;</p>
<pre id="code_1598347655800" class="java" data-ke-language="java" data-ke-type="codeblock"><code>static int[] dx = {0, 0, 1, -1}; // 간선 4방향의 x축을 담당한다.
static int[] dy = {1, -1, 0, 0}; // 간선 4방향의 y축을 담당한다.

...

static void dfs(int x, int y) { // dfs 탐색
        d[x][y] = true; // 방문 마킹
        res[residx]++; // 방문 한 상황이므로 단지의 가구수의 값 증가시킨다
        for(int k = 0; k &lt; 4; k++) { // 4방향 간선 탐색
            int nx = x + dx[k];
            int ny = y + dy[k];
            if(0 &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; n) { // 가장자리 체크
                if(a[nx][ny] == 1 &amp;&amp; !d[nx][ny]) {
                    // 방문을 안했고, 데이터값이 '1'이면 dfs 진행.
                    dfs(nx, ny);
                }
            }
        }
    }</code></pre>
<p>방향을 저장한 dx, dy배열을 만들어 놓고 반복문으로 한번에 처리했다.</p>
<p>이렇게 하면 이문제 뿐만 아니라 다른 dfs나 bfs문제도 훨씬 깔끔하게 풀수 있을것 같다.</p>
<p>&nbsp;</p>
<p><u>bfs</u></p>
<p>&nbsp;</p>
<p>bfs탐색을 이용한 코드는 내가 미로탐색이나 토마토에서 쓴 bfs 코드랑 비슷했고&nbsp;</p>
<p>다른 점은 Pair을 이용한 것이었다.</p>
<p>&nbsp;</p>
<p>bfs 코드를 짤때 내가 궁금했던것이 이거 였는데 java는 c++의 Pair이 없는 것 같았다.</p>
<p>그래서 고민하다 그냥 큐에 두개씩 넣고 두개씩 빼는 방법을 사용했는데,</p>
<p>솔루션에서는 그냥 직접 Pair라는 class를 만들어서 사용했다.&nbsp;</p>
<p>&nbsp;</p>
<pre id="code_1598349054500" class="java" data-ke-language="java" data-ke-type="codeblock"><code>class Pair { // Queue에 넣을 데이터 클래스
    int x, y;
    public Pair(int _x, int _y) {
        x = _x;
        y = _y;
    }
}</code></pre>
<p>이렇게 Pair 클래스를 직접 만들었다.</p>
<p>그 후</p>
<pre id="code_1598349095607" class="java" data-ke-language="java" data-ke-type="codeblock"><code>static void bfs(int x, int y) {
        Queue&lt;Pair&gt; q = new LinkedList&lt;Pair&gt;();
        
        q.add(new Pair(x, y)); // 시작 지점을 큐에 넣는다</code></pre>
<p>Queue를 Pair형으로 선언하고, Pair를 큐에 넣는다.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
                        </div>
                        <br/>
                        <div class="tags">
                            #Java #graph #dfs 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
