
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>10973. 이전 순열</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">10973. 이전 순열</h2>
                                <div class="box-info">
                                    <p class="category">PS</p>
                                    <p class="date">2020-09-03 22:16:21</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p><a href="https://www.acmicpc.net/problem/10973">https://www.acmicpc.net/problem/10973</a></p>
<figure id="og_1599133967463" contenteditable="false" data-ke-type="opengraph" data-og-type="website" data-og-title="10973번: 이전 순열" data-og-description="첫째&nbsp;줄에 입력으로 주어진 순열의 이전에 오는 순열을 출력한다. 만약, 사전순으로 가장 처음에 오는 순열인 경우에는 -1을 출력한다." data-og-host="www.acmicpc.net" data-og-source-url="https://www.acmicpc.net/problem/10973" data-og-url="https://www.acmicpc.net/problem/10973" data-og-image="https://scrap.kakaocdn.net/dn/cV4vi7/hyHnTjtfYa/3IdtgbvkLyMF8ziHOuoD7k/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630"><a href="https://www.acmicpc.net/problem/10973" target="_blank" rel="noopener" data-source-url="https://www.acmicpc.net/problem/10973">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/cV4vi7/hyHnTjtfYa/3IdtgbvkLyMF8ziHOuoD7k/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630');">&nbsp;</div>
<div class="og-text">
<p class="og-title">10973번: 이전 순열</p>
<p class="og-desc">첫째&nbsp;줄에 입력으로 주어진 순열의 이전에 오는 순열을 출력한다. 만약, 사전순으로 가장 처음에 오는 순열인 경우에는 -1을 출력한다.</p>
<p class="og-host">www.acmicpc.net</p>
</div>
</a></figure>
<p>&nbsp;</p>
<p>다음 순열이랑 똑같은데 그냥 다음이 아닌 이전 순열을 구함.</p>
<p>&nbsp;</p>
<p>먼저 <b>다음 순열</b>을 구할때 어떻게 구했는지 다시 살펴보면</p>
<p><figure class="imageblock alignCenter" data-filename="20200903205914.png" data-origin-width="1012" data-origin-height="380" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img.png" data-filename="20200903205914.png" data-origin-width="1012" data-origin-height="380" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p>1. A[i-1] &lt; A[i]인 가장 큰 i를 찾는다.&nbsp;</p>
<p>2. A[i-1]보다 <b>큰</b> 가장 오른쪽에 있는(가장 큰)수를 j라고 한다. (이때 j &gt;= i)</p>
<p>3. A[i-1]과 A[j]를 Swap한다.</p>
<p>4. i 부터 n까지 reverse한다.&nbsp;</p>
<p>&nbsp;</p>
<p>그럼 <b>이전 순열</b>을 구할때는 반대로 하면 되지 않을까</p>
<p><figure class="imageblock alignCenter" data-filename="20200903210045.png" data-origin-width="1100" data-origin-height="409" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png" data-filename="20200903210045.png" data-origin-width="1100" data-origin-height="409" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p>1. A[i-1] &gt; A[i] 인 가장 큰 i를 찾는다.</p>
<p>2. A[i-1]보다 <b>작은</b> 가장 오른쪽에 있는(가장 큰) j를 찾는다. (이때 j &gt;= i)</p>
<p>3. A[i-1]과 A[j]를 Swap한다.</p>
<p>4. i부터 n까지 reverse 한다.</p>
<p>&nbsp;</p>
<div data-ke-type="moreLess" data-text-more="더보기" data-text-less="닫기">
<div class="moreless-content-ignore">
<pre id="code_1599138949004" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
using namespace std;

void DoSwap(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

bool res(int *a, int n) {
    int i_idx = -1;
    for(int i = 1; i &lt; n; i++) {   // a[i-1] &gt; a[i]인 가장 큰 i 찾음
        if(a[i-1] &gt; a[i]) i_idx = i;
    }
    if(i_idx == -1) return false;

    int j_idx;
    for(int i = i_idx; i &lt; n; i++) { // a[i-1]보다 작은 가장 큰 j 찾음. (j &gt;= i)
        if(a[i] &lt; a[i_idx-1]) j_idx = i;
    }

    DoSwap(&amp;a[i_idx-1], &amp;a[j_idx]); // swap

    int i = i_idx;
    int j = n-1;
    while(i &lt; j) { // reverse
        DoSwap(&amp;a[i], &amp;a[j]);
        i++; j--;
    }

    return true;
}

int main() {
    int a[10001];
    int n;
    cin &gt;&gt; n;

    for(int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
    }

    if(res(a, n)) {
        for(int i = 0; i &lt; n; i++) {
            cout &lt;&lt; a[i] &lt;&lt; " ";
        }
    }
    else
        cout &lt;&lt; "-1";

}</code></pre>
</div>
</div>
<p>이번엔 reverse 부분도 직접 구현해 봤다.</p>
                        </div>
                        <br/>
                        <div class="tags">
                            #Brute Force #CPP 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
