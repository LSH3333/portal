
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>Week2. Analyzing Divide-and-conquer Algorithms~</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">Week2. Analyzing Divide-and-conquer Algorithms~</h2>
                                <div class="box-info">
                                    <p class="category">학교/알고리즘 및 실습</p>
                                    <p class="date">2020-09-17 20:18:34</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p><b>Analyzing divde-and-conquer algorithms</b></p>
<p>&nbsp;</p>
<p><b>T(n</b>) : running time on a probelm of size n.</p>
<p>Problem의 크기가 아주 작으면, 예를들어 n &lt;= c(c는 상수)이면 O(1)이면 해결.</p>
<p>&nbsp;</p>
<p>문제를 나눠서 a의 subproblems가 생기고, original의 1/b의 크기이면,</p>
<p>크기 n/b의 subproblem 하나를 해결하는데 T(n/b)가 걸림.</p>
<p>&nbsp;</p>
<p>a개의 subproblems가 존재하므로 모두 해결하려면 aT(n/b)의 시간이 걸림.</p>
<p>&nbsp;</p>
<p><b>D(n</b>): divide the problem into subproblems&nbsp;</p>
<p><b>C(n)</b>: combine the solutions to the subproblems into the solution to the original problem.</p>
<p>then,</p>
<p>&nbsp;</p>
<p><b>T(n</b>) = O(1)&nbsp; &nbsp; &nbsp;// if n&lt;=c,</p>
<p>&nbsp; &nbsp; &nbsp; = aT(n/b) + D(n) + C(n)&nbsp; &nbsp; &nbsp;// otherwise</p>
<p>&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<p><b>Analyisis of merge sort</b></p>
<p>&nbsp;</p>
<p><b>Divide</b>: Divide 스탭에서는 단순히 subarray의 중간을 계산, takes constant time.</p>
<p>&nbsp;그러므로 <b>D(n) = O(1)</b></p>
<p>&nbsp;</p>
<p><b>Conquer</b>: 두개의 subproblems를 재귀적으로 해결, 각 subproblem은 n/2의 크기.&nbsp;</p>
<p>&nbsp;즉 <b>2T(n/2)</b></p>
<p>&nbsp;</p>
<p><b>Combine</b>: n개의 원소로 이루어진 subarray의 MERGE 알고리즘의 소요시간은 O(n).</p>
<p>&nbsp;즉 <b>C(n) = O(n)</b></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>O(n)과 O(1)의 합은 O(n). 즉</p>
<p>&nbsp;</p>
<p><b>T(n)</b> = O(1)&nbsp; &nbsp; // if n = 1,</p>
<p>&nbsp; &nbsp; &nbsp; = 2T(n/2) + O(n)&nbsp; // if n &gt; 1.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<p><b>Recursion Tree</b><b></b></p>
<p>&nbsp;</p>
<p><figure class="imageblock alignCenter" data-filename="20200917193759.png" data-origin-width="575" data-origin-height="675" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img.png" data-filename="20200917193759.png" data-origin-width="575" data-origin-height="675" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p>(a) T(n)</p>
<p>&nbsp;</p>
<p>(b) recurrence를 표현하는 equivalent tree.</p>
<p>&nbsp;cn은 root.&nbsp;</p>
<p>&nbsp;root의 두개의 subtrees는 두개의 더 작은 recurrences T(n/2).</p>
<p>&nbsp;</p>
<p>(c) 이전 (b)의 1step 확장.&nbsp;</p>
<p>&nbsp;</p>
<p>Problem size가 1일 될때까지 이렇게 확장을 반복.</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<p># <b>log tree의 height</b> =&nbsp;</p>
<p><figure class="imageblock alignLeft" data-filename="CodeCogsEqn.gif" data-origin-width="45" data-origin-height="18" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img.gif" data-filename="CodeCogsEqn.gif" data-origin-width="45" data-origin-height="18" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p>ex) tree that has 4 leaves, its height is 2. which is</p>
<p><figure class="imageblock alignLeft" data-filename="CodeCogsEqn (2).gif" data-origin-width="76" data-origin-height="18" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img_1.gif" data-filename="CodeCogsEqn (2).gif" data-origin-width="76" data-origin-height="18" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p>&nbsp;</p>
<p><figure class="imageblock alignCenter" data-filename="20200917200413.png" data-origin-width="440" data-origin-height="250" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png" data-filename="20200917200413.png" data-origin-width="440" data-origin-height="250" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p>height : 간선의 수.</p>
<p>&nbsp;</p>
<p><b># number of the levels of the tree is its height+1.</b></p>
<p>&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<p>total run time of merge sort is the sum of all the run times at all levels.</p>
<p>&nbsp;</p>
<p>then the total run time of merge sort is&nbsp;</p>
<p><figure class="imageblock alignLeft" data-filename="CodeCogsEqn (3).gif" data-origin-width="111" data-origin-height="17" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img_2.gif" data-filename="CodeCogsEqn (3).gif" data-origin-width="111" data-origin-height="17" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p>(terms for n's, Not a recurence)</p>
<p>&nbsp;</p>
<p>O(nlogn)으로도 표현가능.&nbsp;</p>
<p>&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style2" />
<p>&nbsp;</p>
<p><b>Chapter3. Growth of Functions</b></p>
<p>&nbsp;</p>
<p>It is natural to represent the run times by the function of data size.</p>
<p>but we do not compare the run times of algorithms by their <b>precise functions.</b></p>
<p>Actually, we compare them by the <b>major part of the functions.</b></p>
<p>&nbsp;</p>
<p>f(n) = O(g(n)) // f(n) is element of set O(g(n))</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // f(n) &lt;= c * g(n)</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Asympotic notation으로 나타난 funcion은 보통 알고리즘의 running time을 나타내지만,</p>
<p>running time외에도 시간,공간등 어떤것도 나타낼수 있다.</p>
<p>&nbsp;</p>
<p>worst running time 외에도 어떤 input도 cover가능.</p>
<p>&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<p><b>Big-O-notation</b></p>
<p>&nbsp;</p>
<p>insertion sort의 worst-cast running time은&nbsp;</p>
<p><span style="color: #333333;">T(n) = O(n^2)</span></p>
<p>&nbsp;</p>
<p>이게 무슨 의미일까?</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
                        </div>
                        <br/>
                        <div class="tags">
                            
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
