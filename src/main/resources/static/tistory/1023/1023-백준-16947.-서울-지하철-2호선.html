
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>백준 16947. 서울 지하철 2호선</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">백준 16947. 서울 지하철 2호선</h2>
                                <div class="box-info">
                                    <p class="category">PS</p>
                                    <p class="date">2023-01-19 14:59:15</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p data-ke-size="size16"><a href="https://www.acmicpc.net/problem/16947" target="_blank" rel="noopener">https://www.acmicpc.net/problem/16947</a></p>
<figure id="og_1674106891711" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="16947번: 서울 지하철 2호선" data-og-description="첫째 줄에 역의 개수 N(3 &le; N &le; 3,000)이 주어진다. 둘째 줄부터 N개의 줄에는 역과 역을 연결하는 구간의 정보가 주어진다. 같은 구간이 여러 번 주어지는 경우는 없고, 역은 1번부터 N번까지 번호" data-og-host="www.acmicpc.net" data-og-source-url="https://www.acmicpc.net/problem/16947" data-og-url="https://www.acmicpc.net/problem/16947" data-og-image="https://scrap.kakaocdn.net/dn/K6324/hyRlpeUVgK/RiApGFPBQhlWEvau8andik/img.png?width=2834&amp;height=1480&amp;face=0_0_2834_1480,https://scrap.kakaocdn.net/dn/QdOqm/hyRkhizNvu/mIggw9zLrKCuXtskx86f2K/img.png?width=1000&amp;height=1125&amp;face=0_0_1000_1125"><a href="https://www.acmicpc.net/problem/16947" target="_blank" rel="noopener" data-source-url="https://www.acmicpc.net/problem/16947">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/K6324/hyRlpeUVgK/RiApGFPBQhlWEvau8andik/img.png?width=2834&amp;height=1480&amp;face=0_0_2834_1480,https://scrap.kakaocdn.net/dn/QdOqm/hyRkhizNvu/mIggw9zLrKCuXtskx86f2K/img.png?width=1000&amp;height=1125&amp;face=0_0_1000_1125');">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">16947번: 서울 지하철 2호선</p>
<p class="og-desc" data-ke-size="size16">첫째 줄에 역의 개수 N(3 &le; N &le; 3,000)이 주어진다. 둘째 줄부터 N개의 줄에는 역과 역을 연결하는 구간의 정보가 주어진다. 같은 구간이 여러 번 주어지는 경우는 없고, 역은 1번부터 N번까지 번호</p>
<p class="og-host" data-ke-size="size16">www.acmicpc.net</p>
</div>
</a></figure>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">문제의 핵심은 그래프에서 사이클을 이루는 노드를 찾는것이다.</p>
<p data-ke-size="size16">사이클이라고 하면 Union-Find을 먼저 떠오르는데 이 문제는 Union-Find 로는 풀기 어려울것 같다.</p>
<p data-ke-size="size16">Union-Find 를 이용하면 간선을 선택했을때 두 노드의 부모가 같다면 해당 간선이 사이클을 만든다는 것을 판단할수 있는데, 이 문제는 정확히 사이클을 이루는 노드들을 판별해야한다.&nbsp;</p>
<p data-ke-size="size16">방법이 있을지 모르겠는데 우선 나는 이 방법은 안된다고 생각하고 dfs와 bfs로 풀었다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">우선 dfs로&nbsp;<b>아직 방문하지 않은 간선</b>만을 타고 이동한다.</p>
<p data-ke-size="size16">방문할때 방문한 노드는 방문 기록하고, 이동할 노드가 없어서 이전 노드로 되돌아올때 방문 체크를 해제한다.</p>
<p data-ke-size="size16">그러다가 시작 노드로 되돌아오게되면 방문 체크한 노드들이 사이클을 이루는 노드들이다.</p>
<p data-ke-size="size16">만약 시작 노드로 되돌아오지 못한다면, 해당 시작 노드는 사이클에 포함되지 않는 것.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이후에는 사이클을 이루는 노드들을 찾았으므로 모든 노드들에 대하여 사이클을 이루는 노드들의 최단거리를 bfs로 탐색하면 된다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<script src="https://gist.github.com/LSH3333/82cebd4acc8a274334e66b1c78707603.js"></script>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<p data-ke-size="size16">다른 분들 풀이를 보니 <b>양방향 그래프에서 사이클을 이루는 노드를 찾는 방법은 dfs의 backEdge를 이용해 찾는다고 한다.</b></p>
<p data-ke-size="size16"><b>백엣지라는 것은 노드를 이동할때 조상 노드(즉 이미 방문한 노드) 로 이동하는 엣지를 backEdge라고 한다.</b></p>
<p data-ke-size="size16">예를들어 다음과 같은 양방향 그래프가 있을때를 생각해보자.&nbsp;</p>
<p><figure class="imageblock alignCenter" width="611" height="375" >
    <span data-lightbox="lightbox">
        <img src="./img/img.png" width="611" height="375"  />
    </span>
    <figcaption>https://www.acmicpc.net/problem/2489</figcaption>
</figure></p>
<p data-ke-size="size16">노드 1부터 dfs 탐색을 시작하면 다음과 같이 순회할것이다.</p>
<p data-ke-size="size16">1 - 3 - 2 - <b>4</b> - 5 - 6 - 7 - 8 -&nbsp; <b>4&nbsp;</b></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">마지막에 노드 8 이후 노드 4로 이동한다.</p>
<p data-ke-size="size16">노드 4는 조상 노드이고, 바로 직계 부모가 아닌 노드이기 때문에 <b>사이클을</b> 이루는 것을 알수 있다.</p>
<p data-ke-size="size16"><span>1 - 3 - 2 -<span>&nbsp;</span></span><b>4<span><span>&nbsp;</span>- 5 - 6 - 7 - 8 -&nbsp;<span>&nbsp;</span></span>4&nbsp;</b></p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p><script src="https://gist.github.com/LSH3333/bfb088fc11573c14131c7c93681ca627.js"></script>
<p data-ke-size="size16">&nbsp;</p>
                        </div>
                        <br/>
                        <div class="tags">
                            #BFS #dfs 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
