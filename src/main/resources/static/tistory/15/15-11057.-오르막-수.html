
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>11057. 오르막 수</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">11057. 오르막 수</h2>
                                <div class="box-info">
                                    <p class="category">PS</p>
                                    <p class="date">2020-08-07 16:14:17</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p><a href="https://www.acmicpc.net/problem/11057">https://www.acmicpc.net/problem/11057</a></p>
<figure id="og_1596710590838" contenteditable="false" data-ke-type="opengraph" data-og-type="website" data-og-title="11057번: 오르막 수" data-og-description="오르막 수는 수의 자리가 오름차순을&nbsp;이루는 수를 말한다. 이때, 인접한 수가 같아도 오름차순으로 친다. 예를 들어, 2234와 3678, 11119는 오르막 수이지만, 2232, 3676, 91111은 오르막 수가 아니다. 수�" data-og-host="www.acmicpc.net" data-og-source-url="https://www.acmicpc.net/problem/11057" data-og-url="https://www.acmicpc.net/problem/11057" data-og-image="https://scrap.kakaocdn.net/dn/bvTz93/hyG2nfrFzr/4WxiHIPL0BM30XeVK4j6kK/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630"><a href="https://www.acmicpc.net/problem/11057" target="_blank" rel="noopener" data-source-url="https://www.acmicpc.net/problem/11057">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/bvTz93/hyG2nfrFzr/4WxiHIPL0BM30XeVK4j6kK/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630');">&nbsp;</div>
<div class="og-text">
<p class="og-title">11057번: 오르막 수</p>
<p class="og-desc">오르막 수는 수의 자리가 오름차순을&nbsp;이루는 수를 말한다. 이때, 인접한 수가 같아도 오름차순으로 친다. 예를 들어, 2234와 3678, 11119는 오르막 수이지만, 2232, 3676, 91111은 오르막 수가 아니다. 수�</p>
<p class="og-host">www.acmicpc.net</p>
</div>
</a></figure>
<p>&nbsp;</p>
<p>오르막 수는 수의 자리가 오름차순을 이루는 수.&nbsp;</p>
<p>인접한 수가 같아도 오름차순으로 친다.</p>
<p>그리고 이 문제는 0으로 시작할수 있다.</p>
<p>&nbsp;</p>
<p>n = 1 일때</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>...</p>
<p>9</p>
<p>&nbsp;</p>
<p>n = 2 일때</p>
<p>01, 02, ... 09&nbsp; // 9개</p>
<p>12, 13, ... 19 // 8개</p>
<p>23, 24, ... 29 // 7개</p>
<p>...</p>
<p>89&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 1개</p>
<p>&nbsp;</p>
<p>나는 이차원 배열의 첫번 째 인덱스를 수의 길이, 두 번째 인덱스를 수의 첫자리로 사용했다.</p>
<p>위에서 보면 n = 1일때 0이고 n = 2일때는 0뒤에 0보다 큰 값들 (오르막수이기 때문에)이 올 수 있으므로&nbsp;</p>
<p>01, 02, ... 09가 되고 총 9개다.</p>
<p>&nbsp;</p>
<p>n = 1일때 1이면 뒤에 1 보다 큰 수들이 올 수있고 n = 2 일때 12, 13, ... 19 가 되고 총 8개다.</p>
<p>이렇게 앞자리가 1씩 커질수록 뒤에 올 수 있는 수의 개수가 1씩 적어진다.&nbsp;</p>
<pre id="code_1596783460695" class="python" data-ke-language="python" data-ke-type="codeblock"><code>d = [[0] * 10 for i in range(1001)]  # 1001 x 10

for i in range(10):  # base
    d[1][i] = 1


def dp(a, b):
    for i in range(9, b - 1, -1):
        d[a][b] += d[a - 1][i]

    return d[a][b]


n = int(input())  # input

for i in range(2, n + 1, 1):
    for j in range(10):
        d[i][j] = dp(i, j)

res = 0
for i in range(10):
    res += d[n][i]

print(res % 10007)</code></pre>
<p>n = 1일때는 어처피 두 번째 인덱스는 상관없이 모두 1가지만 있을수 있으므로 d[1]은 다 1로 채운다.</p>
<p>&nbsp;</p>
<p>for문이 돌면서 dp함수를 호출해서 d[][]를 채운다.&nbsp;</p>
<p><span style="color: #333333;">예를들어 n = 2이면,</span></p>
<p>d[2][0]에는 d[1][9], d[1][8] ... d[1][0]이 더해져 9가되고,</p>
<p>d[2][1]에는 d[1][9], d[1][8] ... d[1][1]이 더해져 8이 된다.</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style6" />
<p><b>Solution</b></p>
<p>&nbsp;</p>
<p>d[n] : 길이가 n 자리인 수 중에서 오르막수의 총 개수</p>
<p>&nbsp;</p>
<p>이 문제도 숫자의 마지막 자리의 수가 몇인지가 중요하다.</p>
<p>그래서 <b>d[n][k]에서 n은 길이, k는 마지막 자리의 값으로 둔다.</b></p>
<p>&nbsp;</p>
<p>그래서 우리가 구하는 값은&nbsp;</p>
<p>d[n] = d[n][0] + d[n][1] + ... + d[n][9]</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>중요한 것은 d[n][k] 에서 k 값이 d[n-1][i]의 i 값보다 크거나 같아야 '오르막 수' 가 된다는 것이다.&nbsp;</p>
<p>즉 <b>d[n][k] = d[n-1][0] + d[n-1][1] + ... + d[n-1][k]</b></p>
<p>&nbsp;</p>
<pre id="code_1596784394180" class="python" data-ke-language="python" data-ke-type="codeblock"><code>d = [[0] * 10 for a in range(1001)]
for a in range(10): d[1][a] = 1  # 길이 1일때는 모두 1
mod = 10007

n = int(input())
for i in range(2, n+1):
    for k in range(10):
        for j in range(k + 1):
            d[i][k] += d[i-1][j]
            d[i][k] %= mod  # 배열에 넣을때부터 애초에 10007 나머지 넣는다

sum = 0
for i in range(10): sum += d[n][i]</code></pre>
<p>&nbsp;</p>
                        </div>
                        <br/>
                        <div class="tags">
                            #Python #DP 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
