
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>백준 15970. 화살표 그리기</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">백준 15970. 화살표 그리기</h2>
                                <div class="box-info">
                                    <p class="category">PS</p>
                                    <p class="date">2021-07-22 18:35:20</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p data-ke-size="size16"><a href="https://www.acmicpc.net/problem/15970" target="_blank" rel="noopener">https://www.acmicpc.net/problem/15970</a></p>
<figure id="og_1626946183178" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="15970번: 화살표 그리기" data-og-description="직선 위에 위치를 나타내는 0, 1, 2, ...와 같은 음수가 아닌 정수들이 일정한 간격으로 오른쪽 방향으로 놓여 있다. 이러한 위치들 중 N개의 위치에 하나씩 점들이 주어진다(&lt;그림 1&gt;). 주어진 점들" data-og-host="www.acmicpc.net" data-og-source-url="https://www.acmicpc.net/problem/15970" data-og-url="https://www.acmicpc.net/problem/15970" data-og-image="https://scrap.kakaocdn.net/dn/bDWRDJ/hyKXNIehPQ/gHXbIaXhs6xqUMLpKMSu11/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630"><a href="https://www.acmicpc.net/problem/15970" target="_blank" rel="noopener" data-source-url="https://www.acmicpc.net/problem/15970">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/bDWRDJ/hyKXNIehPQ/gHXbIaXhs6xqUMLpKMSu11/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630');">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">15970번: 화살표 그리기</p>
<p class="og-desc" data-ke-size="size16">직선 위에 위치를 나타내는 0, 1, 2, ...와 같은 음수가 아닌 정수들이 일정한 간격으로 오른쪽 방향으로 놓여 있다. 이러한 위치들 중 N개의 위치에 하나씩 점들이 주어진다(&lt;그림 1&gt;). 주어진 점들</p>
<p class="og-host" data-ke-size="size16">www.acmicpc.net</p>
</div>
</a></figure>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">일단 생각 가는대로 풀어서 100점을 맞긴했는데 내가 봐도 이건 좀 아닌것 같다.</p>
<p data-ke-size="size16">일단 어떻게 풀었는지 기록해놓고 다른 더 좋은 방법을 생각해봐야겠다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">1. vector&lt;pair&lt;int,int&gt;&gt; 에 저장한 후 second기준 즉 같은 색을 기준으로 정렬</p>
<p data-ke-size="size16">2. 같은 색이 끝나는 지점의 인덱스를 기억해놨다가 그 인덱스 범위 (같은 색 범위) 안에서 first기준 즉 숫자를 오름차순으로 정렬.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">3. 여기까지 하면 벡터에는 같은색 기준으로 정렬되어 있고 같은 색끼리는 오름차순으로 정렬됨.</p>
<p data-ke-size="size16">ex)</p>
<p data-ke-size="size16">5</p>
<p data-ke-size="size16">0<span> </span>1</p>
<p data-ke-size="size16">1<span> </span>2</p>
<p data-ke-size="size16">3<span> </span>1</p>
<p data-ke-size="size16">4<span> </span>2</p>
<p data-ke-size="size16">5<span> </span>1</p>
<p data-ke-size="size16">input이 위와 같다면 아래와 같이 정렬됨&nbsp;</p>
<p data-ke-size="size16">0 1</p>
<p data-ke-size="size16">3 1</p>
<p data-ke-size="size16">5 1</p>
<p data-ke-size="size16">1 2</p>
<p data-ke-size="size16">4 2</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">4. 이제 루프를 돌면서 이전 점, 다음 점의 거리 중 작은 값을 더해가면됨. (같은 색 끼리만)</p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1626946506393" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
using namespace std;

int n;
vector&lt;pair&lt;int,int&gt;&gt; v;
queue&lt;int&gt; colIdx;
int ans = 0;

// pair의 second 기준 오름차순 정렬
bool compare(const pair&lt;int,int&gt;&amp; a, const pair&lt;int,int&gt;&amp; b)
{
    return a.second &lt; b.second;
}

int main()
{
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i++)
    {
        int a, b;
        cin &gt;&gt; a &gt;&gt; b;
        v.push_back({a,b});
    }

    // second기준으로 정렬 (색깔별로 정렬)
    sort(v.begin(), v.end(), compare);


    // 하나의 색깔의 마지막 인덱스가 저장되어있는 colIdx 큐 만들기
    // 이 큐를 이용해 이후에 같은 색깔들을 first 기준 오름차순 정렬할것임
    int color = v[0].second; // 1
    for(int i = 0; i &lt; n; i++)
    {
        if(v[i].second != color)
        {
            colIdx.push(i-1);
            color = v[i].second; // 2
        }
    }
    colIdx.push(v.size()-1);


    // first를 기준으로 같은 색들끼리 정렬한다
    int temp = 0;
    while(!colIdx.empty())
    {
        sort(v.begin() + temp , v.begin() + colIdx.front()+1);
        temp = colIdx.front()+1;
        colIdx.pop();
    }

    // 정렬된 벡터를 돌면서 화살표의 길이를 구해 더한다
    for(int i = 0; i &lt; n; i++)
    {
        if(i == 0)
        {
            ans += abs(v[1].first - v[0].first);
        }
        else if(i == n-1)
        {
            ans += abs(v[n-2].first - v[n-1].first);
        }
        else
        {
            int a,b;
            if(v[i-1].second != v[i].second)
                a = 999999999;
            else
                a = abs(v[i].first - v[i-1].first);

            if(v[i+1].second != v[i].second)
                b = 999999999;
            else
                b = abs(v[i].first - v[i+1].first);

            int smaller = min(a,b);
            ans += smaller;
        }
    }

    cout &lt;&lt; ans;
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<p data-ke-size="size16">어제 풀었던 풀이가 영 아닌것 같아서 다시 풀어봤다.</p>
<p data-ke-size="size16">다른 분들이 푼것을 보다가 벡터의 배열을 만들어서 같은 색은 같은 행에 푸쉬되도록 한 것을 봤다.</p>
<p data-ke-size="size16">그런데 내기억에 나도 처음에 이렇게 풀려했던것같은데 어쩌다가 저렇게 풀고있었지..?</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">어제 내가 푼 방식은 (점,색깔)을 pair형태로 벡터에 푸쉬해서 색별로 정렬하고 그후에 또다시 같은 색들은 점이 오름차순이 되도록 정렬했다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이렇게 벡터의 배열을 만들어서 같은 색은 같은 행에 저장하면 그럴필요 없이&nbsp;</p>
<p data-ke-size="size16">그냥 값이 있는 행에 대해서만 오름차순으로 정렬한후 계산을 하면 된다.</p>
<p data-ke-size="size16">&nbsp;</p>
<pre id="code_1627018307453" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
#define MAX 5001

int n;
int ans = 0;

vector&lt;int&gt; v[MAX];

int main()
{
    cin &gt;&gt; n;
    // 같은 color는 같은 행에 푸쉬
    for(int i = 0; i &lt; n; i++)
    {
        int point, color;
        cin &gt;&gt; point &gt;&gt; color;

        v[color].push_back(point);
    }

    // 색깔은 1부터 n까지
    for(int i = 1; i &lt;= n; i++)
    {
        // 해당 행이 비어있으면 continue
        if(v[i].empty()) continue;

        // 오름차순으로 정렬
        sort(v[i].begin(), v[i].end());

        for(int j = 0; j &lt; v[i].size(); j++)
        {
            // 제일 왼쪽점의 화살표는 바로 오른쪽점을 향할수 밖에 없다
            if(j == 0)
                ans += abs(v[i][0] - v[i][1]);

            // 제일 오른쪽점의 화살표는 바로 왼쪽점을 향할수 밖에 없다
            else if(j == v[i].size()-1)
                ans += abs(v[i][j] - v[i][j-1]);

            // 중간 점들
            else
            {
                // 양쪽 같은색 점 중, 가까운 곳의 거리를 합한다
                int a = abs(v[i][j-1] - v[i][j]);
                int b = abs(v[i][j+1] - v[i][j]);
                ans += min(a,b);
            }
        }
    }
    cout &lt;&lt; ans;
}</code></pre>
                        </div>
                        <br/>
                        <div class="tags">
                            #C++ #Brute Force 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
