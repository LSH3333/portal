
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>10971. 외판원 순회2</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">10971. 외판원 순회2</h2>
                                <div class="box-info">
                                    <p class="category">PS</p>
                                    <p class="date">2020-09-27 10:55:11</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p><a href="https://www.acmicpc.net/problem/10971" target="_blank" rel="noopener">www.acmicpc.net/problem/10971</a></p>
<figure id="og_1601171426922" contenteditable="false" data-ke-type="opengraph" data-og-type="website" data-og-title="10971번: 외판원 순회 2" data-og-description="첫째 줄에 도시의 수 N이 주어진다. (2 &le; N &le; 10) 다음 N개의 줄에는 비용 행렬이 주어진다. 각 행렬의 성분은 1,000,000 이하의 양의 정수이며, 갈 수 없는 경우는 0이 주어진다. W[i][j]는 도시 i에서 j" data-og-host="www.acmicpc.net" data-og-source-url="https://www.acmicpc.net/problem/10971" data-og-url="https://www.acmicpc.net/problem/10971" data-og-image="https://scrap.kakaocdn.net/dn/QJj1C/hyHDnMMjZQ/pkUXsoo4SdKxROdem6giT0/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630"><a href="https://www.acmicpc.net/problem/10971" target="_blank" rel="noopener" data-source-url="https://www.acmicpc.net/problem/10971">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/QJj1C/hyHDnMMjZQ/pkUXsoo4SdKxROdem6giT0/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630');">&nbsp;</div>
<div class="og-text">
<p class="og-title">10971번: 외판원 순회 2</p>
<p class="og-desc">첫째 줄에 도시의 수 N이 주어진다. (2 &le; N &le; 10) 다음 N개의 줄에는 비용 행렬이 주어진다. 각 행렬의 성분은 1,000,000 이하의 양의 정수이며, 갈 수 없는 경우는 0이 주어진다. W[i][j]는 도시 i에서 j</p>
<p class="og-host">www.acmicpc.net</p>
</div>
</a></figure>
<p>&nbsp;</p>
<p>모든 이동할 도시의 순서를 구해서 그 값을 각각 구한후 그 최소값이 답.</p>
<p>4개의 도시가 있으면</p>
<p>[1,2,3,4] 즉 1에서2, 2에서3, 3에서4, 4에서1 로 이동하니까 그 비용을 구하고</p>
<p>next_permutation으로 모든 이동가능한 경로를 구한다.</p>
<p>[1,2,3,4], [1,2,4,3], [1,3,2,4] ...&nbsp;</p>
<p>이 모든 경우에서 각각 비용을 구함.</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<p>&nbsp;</p>
<p>처음에 이렇게 했다가 제출 했더니 틀렸다고 뜸.</p>
<p>다시 보니까 길이 막혀있는 경우도 있었다.</p>
<p>어떻게 할지 고민했는데 생각해보니 만약 길이 막혀있으면 결국 돌아서 가야된다는건데</p>
<p>그렇게되면 절때 최소값이 될수 없다.&nbsp;</p>
<p>그러니까 막혀있는 길이 있으면 그냥 예외처리 해주면 된다.</p>
<p>&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<p>위에처럼 해서 냈는데 또 틀렸다고 나왔다 ㅋㅋ.</p>
<p>다시 보니까 마지막 도시에서 처음으로 돌아올때도 길이 막혀있으면 예외처리를 해줘야하는데 뺴먹음.</p>
<p>&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<pre id="code_1601171696932" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int main() {
    int city[11][11]; /// 비용 행렬
    int c[11]; /// 순열
    int res = 0;

    int n; /// 도시의 수
    cin &gt;&gt; n;

    for(int i = 1; i &lt;= n; i++) { /// 비용 행렬 입력, idx맞추기 위해 1부터
        for(int j = 1; j &lt;= n; j++) {
            cin &gt;&gt; city[i][j];
        }
    }

    for(int i = 1; i &lt;= n; i++) { /// permutation 돌릴 초기 순열 1,2,3,4..,n
        c[i] = i;
    }

    int cnt = 0;
    do { /// c 순열 돌리면서 각 도시간 비용 더함
        int sum = 0;
        for(int i = 1; i &lt; n; i++) {
            if(city[c[i]][c[i+1]] == 0) { /// 갈 수 없는 길이 있으면
                sum = res + 100; /// 지금의 res에 값을 더해 절때 최소값이 될수없게함(예외처리)
                break;
            }
            sum += city[c[i]][c[i+1]];
            
        }

        /// 마지막에서 처음도시로 돌아갈때도 갈 수 없으면 예외처리
        if(city[c[n]][c[1]] == 0) sum = res + 100;
        sum += city[c[n]][c[1]]; /// 처음 도시로 다시 돌아가는 비용

        if(cnt == 0) res = sum; /// min값 구하기위해 최초 한번만 res에 결과값 넣음.
        cnt++;

        res = min(res, sum); /// 최소값 갱신.

    } while(next_permutation(c+1, c+n+1));

    cout &lt;&lt; res;
}</code></pre>
                        </div>
                        <br/>
                        <div class="tags">
                            #CPP #next_permutation 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
