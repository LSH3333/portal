
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>프로그래머스. 길 찾기 게임</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">프로그래머스. 길 찾기 게임</h2>
                                <div class="box-info">
                                    <p class="category">PS</p>
                                    <p class="date">2022-01-14 16:02:17</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p data-ke-size="size16"><a href="https://programmers.co.kr/learn/courses/30/lessons/42892" target="_blank" rel="noopener">https://programmers.co.kr/learn/courses/30/lessons/42892</a></p>
<figure id="og_1642143083814" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="website" data-og-title="코딩테스트 연습 - 길 찾기 게임" data-og-description="[[5,3],[11,5],[13,3],[3,5],[6,1],[1,3],[8,6],[7,2],[2,2]] [[7,4,6,9,1,8,5,2,3],[9,6,5,8,1,4,3,2,7]]" data-og-host="programmers.co.kr" data-og-source-url="https://programmers.co.kr/learn/courses/30/lessons/42892" data-og-url="https://programmers.co.kr/learn/courses/30/lessons/42892" data-og-image="https://scrap.kakaocdn.net/dn/odtcx/hyM5LHEaTk/V52nOfKiB5PL3a92RKrks0/img.jpg?width=626&amp;height=626&amp;face=0_0_626_626,https://scrap.kakaocdn.net/dn/gbPvf/hyM5GzzUUw/u3IjzmL9GqNBGpA2bt2n8K/img.jpg?width=626&amp;height=626&amp;face=0_0_626_626"><a href="https://programmers.co.kr/learn/courses/30/lessons/42892" target="_blank" rel="noopener" data-source-url="https://programmers.co.kr/learn/courses/30/lessons/42892">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/odtcx/hyM5LHEaTk/V52nOfKiB5PL3a92RKrks0/img.jpg?width=626&amp;height=626&amp;face=0_0_626_626,https://scrap.kakaocdn.net/dn/gbPvf/hyM5GzzUUw/u3IjzmL9GqNBGpA2bt2n8K/img.jpg?width=626&amp;height=626&amp;face=0_0_626_626');">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">코딩테스트 연습 - 길 찾기 게임</p>
<p class="og-desc" data-ke-size="size16">[[5,3],[11,5],[13,3],[3,5],[6,1],[1,3],[8,6],[7,2],[2,2]] [[7,4,6,9,1,8,5,2,3],[9,6,5,8,1,4,3,2,7]]</p>
<p class="og-host" data-ke-size="size16">programmers.co.kr</p>
</div>
</a></figure>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">이진트리를 구성하고, 전위 순회(preorder), 후위 순회(postorder)를 하는 문제였다.</p>
<p data-ke-size="size16">사실 전위순회, 후위순회를 옛날에 학교에서 배웠는데 정확한 정의가 기억이 안나기도 하고&nbsp;</p>
<p data-ke-size="size16">이런식으로 트리를 구조체로 구성하고 순회하는 문제는 풀어본적이 없어서 다른 분들의 코드를 보고나서 풀었다.</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>트리 구성</b></p>
<p data-ke-size="size16">노드를 표현할 구조체를 정의한다.</p>
<pre class="crmsh"><code>struct Node
{
    int num;
    int x, y;
    Node* left;
    Node* right;
};</code></pre>
<p data-ke-size="size16">연결리스트를 구성할때처럼 left child와 right child를 포인터로 가르키도록 해주면 된다.</p>
<p data-ke-size="size16">트리를 구성하는 방법은 다른 분 코드에서 재귀를 이용해 깔끔하게 구성하는 방법이 있었다.</p>
<p data-ke-size="size16">먼저 Node 구조체가 들어가는 벡터를 만들고 정렬해주는데 y기준 내림차순 정렬, y가 같다면 x기준 오름차순 정렬해준다.&nbsp;</p>
<p data-ke-size="size16">그리고 루트를 기준으로 하는 재귀함수를 만든다.</p>
<pre class="c++ arduino" data-ke-language="c++"><code>void MakeTree(Node *root, Node *child)
{
    // left child
    if(child-&gt;x &lt; root-&gt;x)
    {
        // 현재 기준 루트의 left child가 아직 없으면 할당 후 리턴
        if(root-&gt;left == NULL)
        {
            root-&gt;left = child;
            return;
        }
        // 이미 있다면 기준 루트 변경
        MakeTree(root-&gt;left, child);
    }
    // right child
    else
    {
        if(root-&gt;right == NULL)
        {
            root-&gt;right = child;
            return;
        }
        MakeTree(root-&gt;right, child);
    }
}</code></pre>
<p data-ke-size="size16">함수를 보면 루트를 기준으로 child의 x값이 루트보다 왼쪽에 있으면 child가 left child가 된다.</p>
<p data-ke-size="size16">그런데 만약 root의 left child가 이미 있다면 해당하는 left child를 루트로 하는 재귀함수를 호출한다.</p>
<p data-ke-size="size16">right도 마찬가지다.</p>
<p data-ke-size="size16">즉 첫 재귀에서 그래프의 루트 (가장 위에 있는 노드)에서부터 아래로 내려가면서 child의 자리를 찾는다.&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>전위순회는 Parent -&gt; Left child -&gt; Right child 순으로 탐색한다.&nbsp;</b></p>
<p data-ke-size="size16">재귀를 이용해서 dfs 처럼 함수를 구성하면 아주 깔끔하게 짜여지는것을 볼 수 있다.&nbsp;</p>
<pre class="c++ arduino" data-ke-language="c++"><code>// parent, left, right
vector&lt;int&gt; preorder;
void PreOrder(Node *root)
{
    if(root == NULL) return;

    preorder.push_back(root-&gt;num);
    PreOrder(root-&gt;left);
    PreOrder(root-&gt;right);
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16"><b>후위순회는 Left child -&gt; Right child -&gt; Parent 순으로 탐색한다.</b></p>
<p data-ke-size="size16">마찬가지로 재귀를 이용하면 깔끔하다.</p>
<pre class="c++ arduino" data-ke-language="c++"><code>// left, right , parent
vector&lt;int&gt; postorder;
void PostOrder(Node *root)
{
    if(root == NULL) return;

    PostOrder(root-&gt;left);
    PostOrder(root-&gt;right);
    postorder.push_back(root-&gt;num);
}</code></pre>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">
<script src="https://gist.github.com/LSH3333/7c9d5eaa03ce70c4e8798744357b1b27.js"></script>
</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<p data-ke-size="size16">2022.02.16</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">
<script src="https://gist.github.com/LSH3333/39937dbcae10e068596fcf1dd0c1665f.js"></script>
</p>
                        </div>
                        <br/>
                        <div class="tags">
                            #C++ #Tree #recursion 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
