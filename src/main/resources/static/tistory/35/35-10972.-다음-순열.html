
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>10972. 다음 순열</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">10972. 다음 순열</h2>
                                <div class="box-info">
                                    <p class="category">PS</p>
                                    <p class="date">2020-09-03 19:42:55</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p><a href="https://www.acmicpc.net/problem/10972">https://www.acmicpc.net/problem/10972</a></p>
<figure id="og_1599125873152" contenteditable="false" data-ke-type="opengraph" data-og-type="website" data-og-title="10972번: 다음 순열" data-og-description="첫째&nbsp;줄에 입력으로 주어진 순열의 다음에 오는 순열을 출력한다. 만약, 사전순으로 마지막에 오는 순열인 경우에는 -1을 출력한다." data-og-host="www.acmicpc.net" data-og-source-url="https://www.acmicpc.net/problem/10972" data-og-url="https://www.acmicpc.net/problem/10972" data-og-image="https://scrap.kakaocdn.net/dn/bMgPjf/hyHnHwvMOH/5AVc1YSybREolPHkeuPKsk/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630"><a href="https://www.acmicpc.net/problem/10972" target="_blank" rel="noopener" data-source-url="https://www.acmicpc.net/problem/10972">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/bMgPjf/hyHnHwvMOH/5AVc1YSybREolPHkeuPKsk/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630');">&nbsp;</div>
<div class="og-text">
<p class="og-title">10972번: 다음 순열</p>
<p class="og-desc">첫째&nbsp;줄에 입력으로 주어진 순열의 다음에 오는 순열을 출력한다. 만약, 사전순으로 마지막에 오는 순열인 경우에는 -1을 출력한다.</p>
<p class="og-host">www.acmicpc.net</p>
</div>
</a></figure>
<p>&nbsp;</p>
<p>처음에 난이도가 실버3이고, 정답비율 43퍼길래 쉬운 문제인줄 알았는데 속은것 같다.</p>
<p>아마 43퍼는 permutation함수를 써서 나온 비율이 아닐까.</p>
<p>직접 풀어보려고 꽤 오래 들여다보고 이리저리 끄적여 봤는데(1씩 계속 더해서 모든 자리의 수가 서로 다른 다음의로 큰수를 구해볼까 했는데 아무리 생각해도 시간이 말이안되서 포기) 모르겠어서 구글링을 해봤다.</p>
<p>&nbsp;</p>
<p>구글링하고 느낀점은 찾아본게 정답이었다 아마 계속 봐도 못풀었을것 같다 ㅋㅋ.</p>
<p>결국 이문제는 next_permutation 함수를 직접 구현하는 문제라고 할 수 있다.</p>
<p>&nbsp;</p>
<p>여러 군데에서 찾아봤는데 내가 이해한것을 정리해본다.</p>
<p>&nbsp;</p>
<p><span style="letter-spacing: 0px; background-color: #fafafa; caret-color: auto;">1. 가장 뒤에 있는 감소순열을 찾는다. 즉 A[i-1] &lt; A[i]인 가장 큰 i를 찾는다.</span></p>
<p>&nbsp;</p>
<p style="text-align: center;">A : 2 1 <u><b>5</b> 4 3</u></p>
<p style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//<u> 내림차순</u></p>
<p>A에서 i = 2이다.&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>2. A[i-1]보다 큰 가장 오른쪽에 있는 수가 j이다.&nbsp;</p>
<p>&nbsp;</p>
<p style="text-align: center;">A : 2 1 <b>5</b> 4 <b>3</b></p>
<p style="text-align: left;">A[i-1] = 1 보다 큰 가장 오른쪽에 있는 수는 3. 즉 j&nbsp; = 4</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: left;">3. A[i-1]과 A[j]를 Swap한다.</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: center;">A : 2 <b>1</b> 5 4 <b>3</b>&nbsp; &nbsp;(Swap) --&gt;&nbsp; &nbsp;A : 2 3 <u>5 4 1</u></p>
<p style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <u>// 내림차순</u></p>
<p style="text-align: center;">&nbsp;</p>
<p style="text-align: left;">4. i 부터 끝까지 reverse.</p>
<p style="text-align: left;">&nbsp;</p>
<p style="text-align: center;">A : 2 3 <u>1 4 5</u></p>
<p style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //<u> 오름차순</u></p>
<p style="text-align: left;">&nbsp;</p>
<p>&nbsp;</p>
<p style="text-align: center;">&nbsp;</p>
<p><u>코드</u></p>
<pre id="code_1599128846154" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
using namespace std;
#include &lt;algorithm&gt;

void Doswap(int* x, int* y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

bool res(int *a, int n) {
    int i_idx = -1;
    for(int i = 0; i &lt; n-1; i++) { // i_idx 구함
        if(a[i] &lt; a[i+1]) i_idx = i;
    }
    if(i_idx == -1) return false; // a[i] &lt; a[i+1]인 i 값이 없다, 즉 사전순 마지막에 오는 순열이다.

    int j_idx = 0; // j_idx: a[i_idx]보다 큰 가장 마지막 원소의 위치
    for(int j = i_idx+1; j &lt; n; j++) {
        if(a[i_idx] &lt; a[j]) j_idx = j;
    }

    Doswap(&amp;a[i_idx], &amp;a[j_idx]); // a[i_idx], a[j_idx]값을 서로 바꿈


    reverse(a+i_idx+1, a+(n));

    return true; // 다음 순열을 찾았음.
}

int main() {
    int n;
    cin &gt;&gt; n;
    int a[10001];

    for(int i = 0; i &lt; n; i++) {
        cin &gt;&gt; a[i];
    }

    if(res(a, n)) {
        for(int i = 0; i &lt; n; i++)
            cout &lt;&lt; a[i] &lt;&lt; " ";
    }
    else
        cout &lt;&lt; "-1" &lt;&lt; endl;




}</code></pre>
<p>bool형으로 함수를 만들어서 false가 반환되면 (이미 사전순 마지막에 오는 순열이면) -1를 print.</p>
<p>true 반환되면 변환된 배열 print.&nbsp;</p>
<p>&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<p>추가로 reverse를 함수를 쓰지않고 직접 구현하면 어떻게 해야할지 찾아봤다.</p>
<p>&nbsp;</p>
<p>A : 1 2 <u>3 4 5 6</u> 7 일때, 3~6을 reverse 한다고 하면</p>
<p>첫 인덱스 i = 2, 마지막 인덱스 j = 5이다.&nbsp;</p>
<p>&nbsp;</p>
<pre id="code_1599129451577" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>while(i &lt; j) {
	swap(A[i], A[j])
    i++; j--;
}</code></pre>
<p>이런식으로 i와 j의 위치를 바꿔주고 i값은 1증가, j값은 1감소한다.&nbsp;</p>
<p><figure class="imageblock alignCenter" data-filename="20200903194117.png" data-origin-width="1307" data-origin-height="449" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img.png" data-filename="20200903194117.png" data-origin-width="1307" data-origin-height="449" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<p><b>solution</b></p>
<p>&nbsp;</p>
<p>'bitset' 자료구조를 이용해 bit masking이라는 방법을 썼다.</p>
<p>&nbsp;</p>
<p><u>bitset</u></p>
<pre id="code_1599479667606" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>int main() {
	bitset&lt;5&gt; b(0); // 5bit 크기로 '0'으로 초기화하여 자료 생성.
    b.set(0); // 0번째 비트를 참으로 설정
    b.set(1); // 1번째 비트를 참으로 설정
    cout &lt;&lt; b &lt;&lt; endl; // 00011 출력
    
    b.set(); // 전체 비트 1로 설정
    cout &lt;&lt; b &lt;&lt; end; // 11111 출력
    
    b.reset(4); // 4번째 비트를 0으로 설정
    for(int i = 0; i &lt; 5; i++) cout &lt;&lt; b.test(i); //11110 출력.
    
    }</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>bitset는 인덱스가 반대이다.&nbsp;</p>
<p>b가 0001이면 b.test(0)을 찍으면 1 출력.&nbsp;</p>
<p>&nbsp;</p>
<p><u>bit masking</u></p>
<p>&nbsp;</p>
<p><figure class="imageblock alignCenter" data-filename="20200907210440.png" data-origin-width="609" data-origin-height="76" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img_1.png" data-filename="20200907210440.png" data-origin-width="609" data-origin-height="76" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p>{1,2,3,4} 배열이 있고 처음에 bitset은 모두 1로 초기화 되어있다.</p>
<p>맨 끝 4를 없에고 4의 마스킹도 제거한다.</p>
<p>그리고 4의값을 1증가 시켰더니 최대값은 4를 초과한다.</p>
<p>그럼 다음 비트로 이동한다.</p>
<p>&nbsp;</p>
<p><figure class="imageblock alignCenter" data-filename="20200907210744.png" data-origin-width="609" data-origin-height="79" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img_2.png" data-filename="20200907210744.png" data-origin-width="609" data-origin-height="79" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p>3을 없에고 3의 비트마스킹도 제거.&nbsp;</p>
<p>3에서 1증가시 4.&nbsp;</p>
<p>4의 마스크가 0이므로 4를 마스킹.</p>
<p>&nbsp;</p>
<p><figure class="imageblock alignCenter" data-filename="20200907210909.png" data-origin-width="607" data-origin-height="73" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img_3.png" data-filename="20200907210909.png" data-origin-width="607" data-origin-height="73" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p>&nbsp;</p>
<p>이제 다시 4로가서 값을 1부터 증가시키면서 비트 마스킹확인.</p>
<p>1은 비트마스킹 1.</p>
<p>2는 비트마스킹 1.</p>
<p>3은 비트마스킹 0이므로 3선택.</p>
<p>&nbsp;</p>
<p><figure class="imageblock alignCenter" data-filename="20200907211055.png" data-origin-width="608" data-origin-height="74" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img_4.png" data-filename="20200907211055.png" data-origin-width="608" data-origin-height="74" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p>{1,2,3,4}의 다음순열 {1,2,4,3} 완성.</p>
<p>&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style3" />
<p><u>수정</u></p>
<p>&nbsp;</p>
<p>첫 비트 부터 시작</p>
<p>1. 없에고 마스킹 제거.</p>
<p>2-1. 값 증가 -&gt; 크기 넘거나, 있는 숫자면 다음 비트로 (1번으로)</p>
<p>2-2. 값 증가 -&gt; 증가된 값의 비트마스크 확인</p>
<p>3. 마스크가 0이면 해당 값 선택, 마스킹.</p>
<p>4. 이전 비트로 이동, 1부터 증가시미켜 마스킹 '0'인 숫자 선택. 마스킹 처리.</p>
<p>&nbsp;</p>
<p><figure class="imageblock alignCenter" data-filename="20200913112056.png" data-origin-width="1162" data-origin-height="654" width="752" height="NaN" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img_5.png" data-filename="20200913112056.png" data-origin-width="1162" data-origin-height="654" width="752" height="NaN" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style5" />
<p>유사한 문제를 풀면서 다시 살펴봤는데, 위에 내가 정리한 솔루션은 내가 잘못 이해한것같다.</p>
<p>&nbsp;</p>
<p>1. 마지막 비트에서 시작, 마스킹 제거.</p>
<p><b>2.</b> 값 증가 -&gt; 크기 넘으면 다음 비트.</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -&gt; 크기 안넘으면 그 값의 비트마스크 확인</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -&gt; '0'이면 시작 값 변경 시작할 index 찾음.</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -&gt; '1'이면 <b>2번</b>으로 이동.</p>
<p>&nbsp;</p>
<p>이렇게 하면 값 변경 시작할 index값 찾음. a[idx]값은 이미 자기의 값을 찾은상태.</p>
<p>그러므로 idx+1부터 시작.</p>
<p>&nbsp;</p>
<p>3. 1부터 증가시키면서 비트마스크 값이 '0'인 숫자 선택. 마스킹 처리.&nbsp;</p>
<p>&nbsp;</p>
<pre id="code_1600267189059" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;bitset&gt;
using namespace std;

bitset&lt;20&gt; b(0); /// bit masking
int a[20]; /// 순열

int main() {
    int n;
    cin &gt;&gt; n;

    /// 순열 입력, 인덱스 숫자와 맞추기 위해 1부터.
    for (int i = 1; i &lt;= n; i++) {
        cin &gt;&gt; a[i];
    }

    int trigger = 1;
    int idx = n;
    b.set(); // bit 모두 set.

    while (trigger) {
        b.reset(a[idx]); // 마스킹 제거

        while (1) {
            ++a[idx]; // 값 증가시켜서
            

            if (a[idx] &gt; n) { // 증가시킨값이 n보다 크면
                idx--; // 다음 비트로
                break;
            }
            else if (b.test(a[idx]) == 0) {
                trigger = 0;
                break;
            }
        }
    } //// 여기까지가 값 변경 시작할 idx 구하기.

    // a[idx]는 이전 while루프에서 ++a[idx]하면서 이미 자기 값 찾음.
    b.set(a[idx]);

   // 1부터 증가시키면서 비트마스크 값 '0'인 숫자 선택, 마스킹.
    for (int i = idx + 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= n; j++) {
            if (b.test(j) == 0) {
                a[i] = j; 
                b.set(j); // 1로 set
                break;
            }
        }
    }

    for (int i = 1; i &lt;= n; i++) { // 출력
        cout &lt;&lt; a[i] &lt;&lt; " ";
    }
}</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><figure class="imageblock alignCenter" data-filename="20200918002453.png" data-origin-width="912" data-origin-height="139" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img_6.png" data-filename="20200918002453.png" data-origin-width="912" data-origin-height="139" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p>다시 푼것 정답.. 잘못 이해해서 오래걸렸다..</p>
                        </div>
                        <br/>
                        <div class="tags">
                            #Brute Force #CPP #BitSet 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
