
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>백준 1697. 숨바꼭질</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">백준 1697. 숨바꼭질</h2>
                                <div class="box-info">
                                    <p class="category">PS</p>
                                    <p class="date">2021-04-14 17:30:25</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p><a href="https://www.acmicpc.net/problem/1697" target="_blank" rel="noopener">www.acmicpc.net/problem/1697</a></p>
<figure id="og_1618388495032" contenteditable="false" data-ke-type="opengraph" data-og-type="website" data-og-title="1697번: 숨바꼭질" data-og-description="수빈이는 동생과&nbsp;숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 &le; N &le; 100,000)에 있고, 동생은 점 K(0 &le; K &le; 100,000)에&nbsp;있다.&nbsp;수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 " data-og-host="www.acmicpc.net" data-og-source-url="https://www.acmicpc.net/problem/1697" data-og-url="https://www.acmicpc.net/problem/1697" data-og-image="https://scrap.kakaocdn.net/dn/2WWOv/hyJSa5lRnH/P5khl59fKZsaC10wGCbrf1/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630"><a href="https://www.acmicpc.net/problem/1697" target="_blank" rel="noopener" data-source-url="https://www.acmicpc.net/problem/1697">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/2WWOv/hyJSa5lRnH/P5khl59fKZsaC10wGCbrf1/img.png?width=1200&amp;height=630&amp;face=0_0_1200_630');">&nbsp;</div>
<div class="og-text">
<p class="og-title">1697번: 숨바꼭질</p>
<p class="og-desc">수빈이는 동생과&nbsp;숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 &le; N &le; 100,000)에 있고, 동생은 점 K(0 &le; K &le; 100,000)에&nbsp;있다.&nbsp;수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일</p>
<p class="og-host">www.acmicpc.net</p>
</div>
</a></figure>
<p>수빈이는 걸을때는 1만큼, 순간이동 할때는 현재 위치의 *2 만큼 갈수 있으므로,&nbsp;</p>
<p>그래프를 그린다면 아래와 같을 것이다.&nbsp;</p>
<p>같은 행에서는 걸을때 (1만큼 이동), 아래 행으로 이동할때는 *2 만큼.</p>
<p>&nbsp;</p>
<p>예를들어 현재 위치가 [0][5]라면 걸을때는 1만큼 이동이므로 같은 행의 [0][4], [0][6]과 이어져있고,</p>
<p>순간이동을 한다면 *2 만큼 이동하므로 아래행인 [1][10]과 이어져있다.</p>
<p>&nbsp;</p>
<p><figure class="imageblock alignCenter" data-filename="20210414_172240.jpg" data-origin-width="3827" data-origin-height="1900" width="634" height="NaN" data-ke-mobilestyle="widthContent">
    <span data-lightbox="lightbox">
        <img src="./img/img.jpg" data-filename="20210414_172240.jpg" data-origin-width="3827" data-origin-height="1900" width="634" height="NaN" data-ke-mobilestyle="widthContent" />
    </span>
    <figcaption></figcaption>
</figure></p>
<p>&nbsp;</p>
<p>배열의 크기는 일단 열의 크기는 N과 K의 최댓값인 100000이상은 되어야하고</p>
<p>행의 크기는 아래로 이동(순간이동)할때마다 두배씩 커지므로 2^20 = 1,048,576 이므로 20이면 충분하다.</p>
<p>&nbsp;</p>
<p>다음 인덱스로 넘어갈때 이용할 dr, dc 배열은 왼쪽,오른쪽,아래로 이동하므로 (위로는 갈 필요가 없다) 크기는 3이다.</p>
<p>dr[2] = 1, dc[2] = 2 인 이유는, 내려갈때 행으로는 1을 더해야하고 열은 2를 곱해야해서 그렇다.</p>
<p>따라서 인덱스를 넘어갈때 왼쪽,오른쪽 이동과 아래로 이동은 연산을 다르게 처리해줘야 한다.</p>
<p>&nbsp;</p>
<pre id="code_1618388799684" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
using namespace std;
#include &lt;queue&gt;
#define MAX 100001
#include &lt;utility&gt;

int N, K;
int mark[20][MAX]; // 2^20 = 10만넘으므로 행의 크기는 20으로 해줘도 충분 
// 내려갈때는 행방향으로 1만큼가고 열은 2를 곱해야함. 
int dr[3] = {0, 0, 1};
int dc[3] = {1, -1, 2}; // right(add), left(add), down(multiply)
int idx = 1;

void bfs(int start) {

    queue&lt;pair&lt;int,int&gt;&gt; q;
    q.push(make_pair(0, start));
    mark[0][start] = idx;

    while(!q.empty()) {
        int nr = q.front().first;
        int nc = q.front().second;
        //cout &lt;&lt; "nr: " &lt;&lt; nr &lt;&lt; ' ' &lt;&lt; "nc: " &lt;&lt; nc &lt;&lt; endl;
        q.pop();
        if(mark[nr][nc] &gt; idx) idx++;

        for(int i = 0; i &lt; 3; i++) {
            int nnr, nnc;
            if(i == 2) { // down(multiply)
                nnr = nr + dr[i];
                nnc = nc * dc[i];
            }
            else {
                nnr = nr + dr[i];
                nnc = nc + dc[i];
            }

            if(nnr &lt; 0 || nnr &gt;= 20 || nnc &lt; 0 || nnc &gt;= MAX) continue;
            if(mark[nnr][nnc] != 0) continue;
            q.push(make_pair(nnr,nnc));
            mark[nnr][nnc] = idx + 1;
        }
    }

}

int main() {

    cin &gt;&gt; N &gt;&gt; K;

    bfs(N);

    int ans = MAX;
    for(int i = 0; i &lt; 20; i++) {
        ans = min(ans, mark[i][K]);
    }

    cout &lt;&lt; ans - 1;
}
</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style7" />
<p>다른 분들이 푼 방법을 둘러봤는데, 그냥 1차원 배열로 풀면 되는 것이었다.</p>
<p>나는 2차원으로 만들어서 풀었는데 생각해보면 순간이동을 해서 x2만큼 이동할때 아래 행으로 이동할 이유가 없다.</p>
<p>그냥 같은 열에 두배만큼 이동하면 된다.</p>
<p>&nbsp;</p>
<p>그리고 q에넣을때 pair로 현재 위치와, 깊이를 넣어주고</p>
<p>마지막에 dept를 출력해면 답이다.</p>
<p>&nbsp;</p>
<pre id="code_1618395296117" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
#define MAX 100001

queue&lt;pair&lt;int, int&gt;&gt; q;
bool mark[MAX];
int N,K,result;
int nextmove[3] = {1, -1, 2};

void bfs(int start) {
    q.push({start,0});
    mark[start] = true;

    while(!q.empty()) {
        int loc = q.front().first;
        int depth = q.front().second;
        q.pop();

        if(loc == K) {
            result = depth;
            break;
        }

        for(int i = 0; i &lt; 3; i++) {
            int next_loc;
            if(i == 2) next_loc = loc * nextmove[i];
            else next_loc = loc + nextmove[i];

            if(next_loc &lt; 0 || next_loc &gt; MAX) continue;
            if(!mark[next_loc]) { // not visited yet
                mark[next_loc] = true;
                q.push({next_loc, depth+1});
            }
        }
    }
}

int main() {
    cin &gt;&gt; N &gt;&gt; K;

    bfs(N);

    cout &lt;&lt; result;
}
</code></pre>
<p>&nbsp;</p>
<hr contenteditable="false" data-ke-type="horizontalRule" data-ke-style="style7" />
<p>2021.04.16 추가</p>
<div data-ke-type="moreLess" data-text-more="더보기" data-text-less="닫기">
<div class="moreless-content-ignore">
<pre id="code_1618555838258" class="c++ arduino" data-ke-language="c++" data-ke-type="codeblock"><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
#define MAX 100001

int N,K;
int arr[MAX];
int mark[MAX];
int idx = 1;
int dc[3] = {-1, 1, 2}; /* 좌측1칸, 우측1칸, 두배(곱하기) */

void bfs() {
    queue&lt;int&gt; q;
    q.push(N);
    mark[N] = idx;

    while(!q.empty()) {
        int c = q.front();
        q.pop();
        if(mark[c] &gt; idx) idx++;

        for(int i = 0; i &lt; 3; i++) {
            int nc;
            if(i == 2) { /* 순간이동, 곱하기 */
                nc = c * dc[i];
            }
            else { /* 좌측, 우측 1칸 이동 */
                nc = c + dc[i];
            }

            if(nc &lt; 0 || nc &gt; MAX) continue;
            if(mark[nc] == 0) {
                mark[nc] = idx + 1;
                q.push(nc);
            }

        }
    }
}

int main() {
    cin &gt;&gt; N &gt;&gt; K;
    bfs();

    cout &lt;&lt; mark[K]-1;

}</code></pre>
</div>
</div>
                        </div>
                        <br/>
                        <div class="tags">
                            #C++ #BFS 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
