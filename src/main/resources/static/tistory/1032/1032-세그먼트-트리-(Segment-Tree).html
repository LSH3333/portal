
<meta charset="utf-8">
<html lang="ko">
<head>
    <link rel="stylesheet" type="text/css" href="./../style.css" />
    <title>세그먼트 트리 (Segment Tree)</title>
</head>
<body id="tt-body-page" class="">
<div id="wrap" class="wrap-right">
    <div id="container">
        <main class="main ">
            <div class="area-main">
                <div class="area-view">
                    <div class="article-header">
                        <div class="inner-article-header">
                            <div class="box-meta">
                                <h2 class="title-article">세그먼트 트리 (Segment Tree)</h2>
                                <div class="box-info">
                                    <p class="category">알고리즘</p>
                                    <p class="date">2023-01-22 15:39:42</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <hr>
                    <div class="article-view">
                        <div class="contents_style">
                            <p data-ke-size="size16">아래 블로그를 참고해 정리했습니다.</p>
<p data-ke-size="size16"><a href="https://m.blog.naver.com/ndb796/221282210534" target="_blank" rel="noopener">https://m.blog.naver.com/ndb796/221282210534</a></p>
<figure id="og_1674368202039" contenteditable="false" data-ke-type="opengraph" data-ke-align="alignCenter" data-og-type="article" data-og-title="41. 세그먼트 트리(Segment Tree)" data-og-description="이번 시간에 다룰 내용은 여러 개의 데이터가 연속적으로 존재할 때 특정한 범위의 데이터의 합을 구하는 ..." data-og-host="blog.naver.com" data-og-source-url="https://m.blog.naver.com/ndb796/221282210534" data-og-url="https://blog.naver.com/ndb796/221282210534" data-og-image="https://scrap.kakaocdn.net/dn/iC6t3/hyRlDzvyzx/CWPiMZU5DsNQubq9OJQak0/img.png?width=743&amp;height=357&amp;face=0_0_743_357"><a href="https://m.blog.naver.com/ndb796/221282210534" target="_blank" rel="noopener" data-source-url="https://m.blog.naver.com/ndb796/221282210534">
<div class="og-image" style="background-image: url('https://scrap.kakaocdn.net/dn/iC6t3/hyRlDzvyzx/CWPiMZU5DsNQubq9OJQak0/img.png?width=743&amp;height=357&amp;face=0_0_743_357');">&nbsp;</div>
<div class="og-text">
<p class="og-title" data-ke-size="size16">41. 세그먼트 트리(Segment Tree)</p>
<p class="og-desc" data-ke-size="size16">이번 시간에 다룰 내용은 여러 개의 데이터가 연속적으로 존재할 때 특정한 범위의 데이터의 합을 구하는 ...</p>
<p class="og-host" data-ke-size="size16">blog.naver.com</p>
</div>
</a></figure>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><b>세그먼트 트리의 아이디어</b></h4>
<p data-ke-size="size16">범위를 반으로 나누어서 <b>왼쪽 반의 합은 이진트리의 왼쪽 자식</b>에,&nbsp;</p>
<p data-ke-size="size16"><b>오른쪽 반의 합은 이진트리의 오른쪽 자식</b>에 저장하는 것이다.&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">결국 세그먼트 트리의 각 노드에는 모든 범위의 합이 저장되고, <b>이진트리이므로 탐색은 O(logN)</b>에 끝낼수 있다.&nbsp;</p>
<p data-ke-size="size16">즉 미리 데이터를 가공해 트리를 만들어 놓고 구간합이 필요하면 O(N)이 아닌 O(logN)에 구간합을 구할수 있게 된다.&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><b>세그먼트 트리 생성 시간복잡도</b></h4>
<p data-ke-size="size16">생성할때는 결국 모든 노드들을 한번씩 방문하게 되므로 O(N) 이다.</p>
<p data-ke-size="size16">그런데 N이 기존 배열의 N은 아니고 최종적으로 만들어지는 세그먼트 트리의 노드의 갯수다.&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<h4 data-ke-size="size20"><b>세그먼트 트리에서 구간합 구하기 , 수정 시간복잡도</b></h4>
<p data-ke-size="size16">세그먼트 트리는 이진 트리이므로 높이 logN을 갖는다.</p>
<p data-ke-size="size16">따라서 탐색 시간 복잡도는 O(logN).</p>
<p data-ke-size="size16">&nbsp;</p>
<p data-ke-size="size16">&nbsp;</p>
<script src="https://gist.github.com/LSH3333/569d616621aa24778d20c8be723fda7a.js"></script>
                        </div>
                        <br/>
                        <div class="tags">
                            #segment tree 
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>
</body>
</html>
