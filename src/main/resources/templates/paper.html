<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Paper</title>
    <!-- css style -->
    <link rel="stylesheet" type="text/css" href="/static/css/mainContentBlock.css"
        th:href="@{/css/mainContentBlock.css}" />
    <link rel="stylesheet" type="text/css" href="/static/css/footer.css" th:href="@{/css/footer.css}" />
    <link rel="stylesheet" type="text/css" href="/static/css/header.css" th:href="@{/css/header.css}" />
    <link rel="stylesheet" type="text/css" href="/static/css/paper.css" th:href="@{/css/paper.css}" />
    <link rel="stylesheet" type="text/css" href="/static/css/readmoreBtn.css" th:href="@{/css/readmoreBtn.css}" />


    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cedarville+Cursive&family=Noto+Sans+KR&display=swap"
        rel="stylesheet">
    <link
        href="https://fonts.googleapis.com/css2?family=Cedarville+Cursive&family=Noto+Sans+KR&family=Skranji&display=swap"
        rel="stylesheet">

    <!-- Font Awsome -->
    <script src="https://kit.fontawesome.com/c39d59a5ec.js" crossorigin="anonymous"></script>
</head>

<body>
    <!-- HEADER -->
    <header th:replace="fragment/header :: header">
    </header>

    <!-- MAIN -->
    <main>
   
        <div class="paperArea">
            <div class="explainBlock">
                <p>글들은 제 티스토리 글들의 일부를 가져왔습니다.</p>
                <p><a target="_blank" href="https://lsh-instaweb.herokuapp.com/9/pages/352">> 티스토리 글들 가져온 방법</a></p>
            </div>            
            <h4>Web</h4>
            <hr>
            <div class="paperRow">
                <a th:href="@{/blog/941-Spring-MVC-구조.html}" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/mvc.png}" src="/static/images/papers/mvc.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">Spring MVC 구조</p>
                        <p class="paperBlock_content">
                            DispatcherServlet (Front Controller)
                            이름에 Servlet이 있다시피 DispatcherServlet은 Servlet이고, HttpServlet을 상속 받는다.
                            DispatcherServlet -> FrameworkServlet -> HttpServletBean -> HttpServlet
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/1301-html-파일-fetch,-_script_-동적-실행-등.html}" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/fetch.png}" src="/static/images/papers/fetch.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">html 파일 fetch, &ltscript&gt 동적 실행 등</p>
                        <p class="paperBlock_content">
                            만드는 중인 웹에 내가 티스토리에 쓴 글들을 그대로 가져와 보여주고 싶었다.
                            그 과정과 문제들, 해결한 방법에 대해 기록한다.
                            티스토리에 쓴 글들 (html) 을 내 웹의 디자인을 적용하고 싶다
                            내가 쓴 글들은 천개가 넘는다. 천개의 html 파일들을 모두 수정 불가능
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/1302-Thymeleaf-와-URL-인코딩.html}" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/thymeleaf-logo.png}"
                            src="/static/images/papers/thymeleaf-logo.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">Thymeleaf 와 URL 인코딩</p>
                        <p class="paperBlock_content">
                            서버에서 PathVariable 로 html 파일의 이름을 받는 과정에서 문제가 발생했다.
                            html 파일의 이름에 예약어가 포함될 경우
                            예를들어 '474-c#)-가변배열.html' 같은 경우 '#' 이 포함되는데 # 은 프래그먼트를 나타내는 심볼로서 # 뒤에 나타난 문자열은 서버로 보내지지 않는다.
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/996-JPA-정리.html}" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/jpa.png}" src="/static/images/papers/jpa.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">JPA 정리</p>
                        <p class="paperBlock_content">
                            지금까지 공부한것에 의하면 JPA는 결국 어플리케이션을 만드는 객체지향적 환경과 데이타베이스의 관계형 DB의 환경을 연결해 주는 것이다.
                            어플리케이션의 객체를 다룰때 처럼 데이터베이스의 데이터도 다루고 싶지만 이것이 불가능하다.
                            따라서 데이터를 갖고 뭔가를 하기 전에 객체와 데이터베이스의 테이블을 미리 일일히 매핑을 해놓으면, 내가 객체만 신경쓰면 이미 모두 데이터베이스 테이블에 매핑되어
                            있으므로 JPA가 이에 걸맞는 sql 문을 만들어서 DB에 명령을 내린다.
                        </p>
                    </div>
                </a>
            </div>

            <div class="paperRow">
                <a target="_blank" href="https://tose33.tistory.com/1303" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/oauth.png}" src="/static/images/papers/oauth.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">Google OAuth2</p>
                        <p class="paperBlock_content">
                            요즘 많은 웹사이트들은 구글, 카카오 등으로 로그인을 지원하는데 내 개인정보가 구글,카카오가 아닌 현재 사용중인 웹 서버에도 전달되는지 궁금한 적이 있다.
                            결론부터 말하자면 구글,카카오가 아닌 중간 다리 역할을 하는 웹에는 전달되지 않는다.
                            원리를 아주 아주 간단하게 설명하면 사용자의 개인 정보는 구글에 보내지고, 구글은 중간웹사이트에게 사용자의 아이디,비밀
                        </p>
                    </div>
                </a>

                <a target="_blank" href="https://tose33.tistory.com/1304" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/scretkey.png}" src="/static/images/papers/scretkey.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">git 프로젝트의 secret key 관리, heroku 배포 시 secret key 관리</p>
                        <p class="paperBlock_content">
                            구글 api 에 내 클라이언트를 등록하고 나면 secret key 가 발급되...
                        </p>
                    </div>
                </a>

                <a target="_blank" href="https://tose33.tistory.com/1305" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/webclient.jpg}" src="/static/images/papers/webclient.jpg" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">Spring WebClient</p>
                        <p class="paperBlock_content">
                            WebClient 는 스프링이 제공하는 말 그대로 client 로서의 역할을 하기 위한 모듈이다.
                            동기 API 요청을 처리할때 사용한다.
                            RestTemplate vs WebClient 이전에는 동기 api 요청을 처리할때 RestTemplate 을 사용했는데 위 doc를 보면 아래와 같이
                            spring5.0 부터는 webclient 사용을 권장하고 있다.
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/1192-javascript로-구현한-베지어-곡선.html}" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/bezier.gif}" src="/static/images/papers/bezier.gif" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">javascript로 구현한 베지어 곡선</p>
                        <p class="paperBlock_content">
                            알고리즘 자체는 기존과 다를게 하나도 없지만 javascript 로 옮기면서 해결해야 하는 문제가 있었다.
                            우선 베지어 곡선을 그리는 방법은 다음과 같은데
                            1. N개의 조절점을 이어 N-1 개의 선분을 만든다
                            2. 각 선분의 t 값에 비례하는 곳에 점을 찍는다 (따라서 N-1 개의 새로운 점이 생긴다)
                            3. 1~2를 반복하면 결국 새로운 점의 갯수는 줄어들어 1개의 점이 된다.
                            4. 해당 점의 위치가 베지어 곡선을 그릴때 다음 점의 위치가 된다.
                            5. t 값을 증가시킨다.
                        </p>
                    </div>
                </a>
            </div>

            <div class="paperRow">
                <a th:href="@{/blog/1072-Api-예외-처리.html}" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/api_exception.png}" src="/static/images/papers/api_exception.png"
                            alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">Api 예외 처리</p>
                        <p class="paperBlock_content">
                            오류 페이지는 단순히 사용자에게 에러 페이지를 보여주면 끝이지만, api 통신의 예외는 각 오류에 맞는 오류 응답 스펙을 정하고, JSON 으로 데이터를 보내줘야
                            한다.
                            컨트롤러에서 어떻게든 예외를 처리하지 않으면 서블렛, WAS 까지 갔을때는 무조건 500 대 로 인식한다.
                            아래는 컨트롤러에서 예외가 터졌을때의 흐름이다.
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/743-JDBC.html}" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/jdbc.png}" src="/static/images/papers/jdbc.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">JDBC</p>
                        <p class="paperBlock_content">
                            Java Database Connectivity
                            JDBC(Java Database Connectivity)는 자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API이다.
                            내가 어떤 프로그램을 만들었고 데이터베이스를 사용하는 상황이다.
                            데이터베이스에도 여러 종류가있다 오라클 디비, MSSQL 등등 엄청 많다.
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/760-JDBC-기본-흐름.html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/jdbc_flow.png}" src="/static/images/papers/jdbc_flow.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">JDBC 기본 흐름</p>
                        <p class="paperBlock_content">
                            이전에 쓴대로 기본적인 흐름은 아래와 같다.
                            1. 일단 JDBC 드라이버에 모든 코드들이 있기 때문에 드라이버를 로드해야 할 것이다.
                            Class.forName("oracle.jdbc.driver.OracleDriver");
                            이렇게 하면 메모리에 JDBC 드라이버가 로드된 상태일 것이다.
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/804-Ch12.-MVC-2-_-Bean-Validation을-이용한-검증.html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/beanValid.png}" src="/static/images/papers/beanValid.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">Ch12. MVC 2 : Bean Validation을 이용한 검증</p>
                        <p class="paperBlock_content">
                            @Valid 애노테이션은 Bean Validation 스펙에 정의되어 있다.
                            Bean Validation 스펙이란 특정한 구현체가 아닌 Bean Validation 2.0 이라는 기술 표준을 말한다. (애노테이션과 인터페이스의 모음)
                        </p>
                    </div>
                </a>
            </div>
        </div>

        <div class="paperArea">
            <h4>Languages</h4>
            <hr>
            <div class="paperRow">
                <a th:href="@{/blog/937-Java)-함수의-파라미터에는-복사된-주소값이-전달된다.html}" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/java_param.png}" src="/static/images/papers/java_param.png"
                            alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">Java) 함수의 파라미터에는 복사된 주소값이 전달된다</p>
                        <p class="paperBlock_content">
                            내가 든 의문은 주소값을 복사해서 전달하더라도 어쨌든 주소를 넘겼고 실제로 객체의 데이터도 변경...
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/937-Java)-함수의-파라미터에는-복사된-주소값이-전달된다.html}" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/amortized.png}" src="/static/images/papers/amortized.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">Amortized time complexity</p>
                        <p class="paperBlock_content">
                            내가 이해한 바로는 분할 상환이라는 이름대로, 알고리즘 수행 중 비정상적으로 많은 시간을 소요하는 연산을 분할해서, 나머지 낮은 시간을 소요하는 연산에 분배(상환)해
                            알고리즘의 시간 복잡도를 판단한다는 것이다.
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/988-c++)-객체의-==-비교.html}" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/==comp.png}" src="/static/images/papers/==comp.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">c++) 객체의 == 비교</p>
                        <p class="paperBlock_content">
                            자바에서 == 비교는 객체의 레퍼런스를 비교한다.
                            두 객체가 같은 값을 갖고 있어도 다른 레퍼런스를 갖으면 서로 다르고 == 비교 했을때 false이다.
                            예를들어 아래의 결과는 false 다.
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/661-kotlin)-Array_Int_-vs-IntArray.html}" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/kotlin.png}" src="/static/images/papers/kotlin.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">kotlin) Array&ltInt&gt vs IntArray</p>
                        <p class="paperBlock_content">
                            찾아보니 코틀린의 IntArray, LongArray는 박싱을 안하는 자바로 따지면 int[], long[]과 같고 Array&ltInt&gt,
                            Array&ltLong&gt은 자동 박싱이 진행되는 Integer[] 같은것이라고 한다.
                        </p>
                    </div>
                </a>
            </div>

            <div class="paperRow">
                <a th:href="@{/blog/632-꼬리-재귀-(Tail-Recursion).html}" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/tail_rec.png}" src="/static/images/papers/tail_rec.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">꼬리 재귀 (Tail Recursion)</p>
                        <p class="paperBlock_content">
                            c++로 풀었던 백준 문제를 파이썬으로 변환하다가 메모리 초과가 났다.
                            이유가 뭔지 찾아봤는데 이유는 다음과 같았다.
                            1. c++도 그렇지만 파이썬도 재귀함수를 호출하면 함수가 끝나지 않은채 함수가 또 호출되기 때문에 스택 메모리에 메모리가 계속 쌓이게 된다.
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/600-The-rule-of-3-_-0.html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/rule_of_3.png}" src="/static/images/papers/rule_of_3.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">The rule of 3 / 0</p>
                        <p class="paperBlock_content">
                            만약 클래스에 사용자가 정의한 복사 생성자, 소멸자, 복사 연산자(연산자 오버로딩) 중 하나라도 선언되어 있다면 세가지 모두 선언되어야 한다는 법칙이다.
                            3가지 모두가 필요한 이유는 리소스를 일관되게 관리하기 위함이다.
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/{pageName}(pageName='474-c#)-가변배열.html')}" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/jaggedArr.png}" src="/static/images/papers/jaggedArr.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">c#) 가변배열</p>
                        <p class="paperBlock_content">
                            c#은 특이한 배열이 있는데 바로 가변배열이다.
                            가변배열은 다차원 배열과는 조금 다르다.
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/461-java-buffered.html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/buffered.png}" src="/static/images/papers/buffered.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">java) BufferedReader, BufferedWriter, StringBuilder</p>
                        <p class="paperBlock_content">
                            버퍼를 사용하지 않는 입력은 키보드의 입력이 키를 누르는 즉시 바로 프로그램에 전달된다.
                            버퍼를 사용하는 입력은 키보드의 입력이 있을때마다 버퍼로 전송되고,
                        </p>
                    </div>
                </a>
            </div>
        </div>

        <div class="paperArea">
            <h4>Unity</h4>
            <hr>
            <div class="paperRow">
                <a th:href="@{/blog/715-Coroutine.html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/coroutine.png}" src="/static/images/papers/coroutine.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">Coroutine</p>
                        <p class="paperBlock_content">
                            유니티는 한번에 하나의 일만을 수행하는 단일 쓰레드 방식.
                            Update 함수는 매 프레임 실행되기 때문에 보통 주기적으로 수행해줘야 할 일들을 Update 문에 작성하게 되는데,
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/318-mac에서.html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/macdll.png}" src="/static/images/papers/macdll.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">mac에서 직접 라이브러리 만들기 (dll 파일, unityengine.dll 참조)</p>
                        <p class="paperBlock_content">
                            dll 파일 생성
                            1. Visual Studio에서 파일->새솔루션
                            2. 앱 및 콘솔 -> 라이브러리 -> 클래스 라이브러...
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/179-상속을-이용해-다른-이름의-클래스-스크립트-접근하기.html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/unity_inherit.png}" src="/static/images/papers/unity_inherit.png"
                            alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">상속을 이용해 다른 이름의 클래스 스크립트 접근하기</p>
                        <p class="paperBlock_content">
                            프로젝트 진행중에 문제가 생겼다.
                            구조가 메인타이틀 화면이 있고 거기서 여러개의 작은 미니게임을 선택해서 플레이 하는 방식인데,
                            각각의 미니게임마다 각각의 게임의 점수를 관리하는 스크립트가 있다.
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/162-Lerp와-Time.deltaTime.html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/lerp.webp}" src="/static/images/papers/lerp.webp" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">Lerp와 Time.deltaTime</p>
                        <p class="paperBlock_content">
                            Mathf.Lerp 함수를 쓰면서 이상한 현상을 발견했다.
                            카메라의 Field of View를 Lerp를 이용해서 값을 변경했는데
                            예를들어 아래와 같이 코드를 작성하면
                        </p>
                    </div>
                </a>
            </div>

            <div class="paperRow">
                <a th:href="@{/blog/164-오브젝트를-움직이는-방법들.html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/traslate.png}" src="/static/images/papers/traslate.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">오브젝트를 움직이는 방법들</p>
                        <p class="paperBlock_content">
                            transform.position을 변경하는 움직임
                            void Translate(Vector3 translation);
                            transform.translate는 오브젝트의 transform.position을 translation의 방향과 거리에 따라 이동시켜준다.
                            즉 이 이동방법은 오브젝트의 transform.position 자체를 변경시키면서 이동한다.
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/163-SmoothDamp.html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/smooth.png}" src="/static/images/papers/smooth.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">SmoothDamp</p>
                        <p class="paperBlock_content">
                            Lerp에 관해 찾다가 SmoothDamp 쓰는걸 권장하는 글을 많이봐서 찾아봤다.
                            Vector3 SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float
                            smoothTime)
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/98-Input-Field를-이용한-nickname-입력.html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/inputfield.png}" src="/static/images/papers/inputfield.png"
                            alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">Input Field를 이용한 nickname 입력</p>
                        <p class="paperBlock_content">
                            Hierarchy에서 UI - InputFiled 생성.
                            생성 하면 위와같이 자식이 딸린 InputField 오브젝트 생성됨.
                            Place에서 inputfiled에 보여질 텍스트 수정 할수 있다.
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/76-Animator에서의 transition.html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/animTrigger.png}" src="/static/images/papers/animTrigger.png"
                            alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">Animator에서의 transition, trigger했을때 애니메이션 바로바로 진행되게하기</p>
                        <p class="paperBlock_content">
                            transition의 Has Exit Time : 애니메이션 클립의 재생 시간을 보장할 것인가?
                            활성화 : 종료 시점이 존재하게 되 condition을 만족해도 다음 상태로 전이하지 않음.
                            비활성화 : condition 만족시 즉시 전이.
                        </p>
                    </div>
                </a>
            </div>
        </div>

        <div class="paperArea">
            <h4>Algorithm, Data structure</h4>
            <hr>
            <div class="paperRow">
                <a th:href="@{/blog/1032-세그먼트-트리-(Segment-Tree).html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/segmentTree.png}" src="/static/images/papers/segmentTree.png"
                            alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">세그먼트 트리 (Segment Tree)</p>
                        <p class="paperBlock_content">
                            세그먼트 트리의 아이디어
                            범위를 반으로 나누어서 왼쪽 반의 합은 이진트리의 왼쪽 자식에,
                            오른쪽 반의 합은 이진트리의 오른쪽 자식에 저장하는 것이다.
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/864-Bellman-Ford-Algorithm.html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/bellmanford.gif}" src="/static/images/papers/bellmanford.gif"
                            alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">Bellman Ford Algorithm</p>
                        <p class="paperBlock_content">
                            Bellman Ford 알고리즘은 다익스트라 알고리즘과 비슷하게 하나의 정점에서 다른 정점까지의 최소 비용을 구하는데 음의 가중치가 있어도 사용 가능하다.
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/848-베지어-곡선.html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/bezierCurve.gif}" src="/static/images/papers/bezierCurve.gif"
                            alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">베지어 곡선</p>
                        <p class="paperBlock_content">
                            유니티에서 구현해 봤다.
                            베지어 곡선을 만드는 알고리즘은 재귀적으로 구현하는데 다음과 같이 구현했다.
                            1. n개의 점을 잇는 n-1개의 선분을 만든다.
                            2. 만들어진 각 선분에 t값에 비례하는 곳에 점을 찍는다.
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/616-위상-정렬-(Topology-sort).html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/topologicalSort.png}"
                            src="/static/images/papers/topologicalSort.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">위상 정렬 (Topology sort)</p>
                        <p class="paperBlock_content">
                            토폴로지(영어: topology, 문화어: 망구성방식)는 컴퓨터 네트워크의 요소들(링크, 노드 등)을 물리적으로 연결해 놓은 것, 또는 그 연결 방식을 말한다.
                        </p>
                    </div>
                </a>
            </div>

            <div class="paperRow">
                <a th:href="@{/blog/614-Union-Find-Algorithm.html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/unionFind.png}" src="/static/images/papers/unionFind.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">Union-Find Algorithm</p>
                        <p class="paperBlock_content">
                            Union-Find 알고리즘은 이름 그대로 union(합하고), Find(찾는) 알고리즘이다.
                            서로소 집합 (Disjoint-set) 알고리즘이라고도 불리는데, 두 노드를 선택했을때 두 노드가 같은 그래프에 속하는지 판별하는 알고리즘이기 때문이다.
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/549-Dijkstra-Algorithm-(다익스트라).html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/dijkstra.png}" src="/static/images/papers/dijkstra.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">Dijkstra Algorithm (다익스트라)</p>
                        <p class="paperBlock_content">
                            하나의 정점을 기준으로 나머지 모든 정점까지의 최소비용을 구한다.
                            1. vector&ltpair&ltint,int&gt&gt graph[V] 에 간선 정보 저장함.
                            graph[2] = pair(1,10)이면 2노드에서 1노드까지 10 가중치의 간선 존재
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/533-트라이-자료구조.html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/trie.png}" src="/static/images/papers/trie.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">트라이 자료구조</p>
                        <p class="paperBlock_content">
                            트라이 자료구조는 문자열을 트리의 형태로 저장하는 자료구조다.
                            트리의 각 노드에 문자를 저장해서 관리한다.
                            중복되는 부분이 존재하는 문자열들을 저장하기 용이하고, 문자열을 빠르게 탐색할수 있다.
                        </p>
                    </div>
                </a>

                <a th:href="@{/blog/537-ccw-(Counter-Clockwise).html
                }" class="paperBlock">
                    <div class="imgArea">
                        <img th:src="@{/images/papers/ccw.png}" src="/static/images/papers/ccw.png" alt="">
                    </div>
                    <div class="textArea">
                        <p class="paperBlock_title">ccw (Counter Clockwise)</p>
                        <p class="paperBlock_content">
                            - ccw는 평면에 세 점의 위치가 주어졌을때 점들의 방향성을 판별한다.
                            - 두 벡터의 외적은, 두 벡터에 의해 만들어지는 평행사변형의 넓이와 같다.
                        </p>
                    </div>
                </a>
            </div>
        </div>
    </main>

    <!-- FOOTER -->
    <footer th:replace="fragment/footer :: footer"></footer>
</body>

</html>